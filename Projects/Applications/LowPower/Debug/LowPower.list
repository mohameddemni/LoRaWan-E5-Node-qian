
LowPower.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000138  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000028e0  08000138  08000138  00010138  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000009c  08002a18  08002a18  00012a18  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08002ab4  08002ab4  0002000c  2**0
                  CONTENTS
  4 .ARM          00000000  08002ab4  08002ab4  0002000c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08002ab4  08002ab4  0002000c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08002ab4  08002ab4  00012ab4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08002ab8  08002ab8  00012ab8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000000c  20000000  08002abc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000005c  2000000c  08002ac8  0002000c  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20000068  08002ac8  00020068  2**0
                  ALLOC
 11 .ARM.attributes 0000002a  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00008d32  00000000  00000000  00020036  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001bfb  00000000  00000000  00028d68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000d38  00000000  00000000  0002a968  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000c70  00000000  00000000  0002b6a0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00017e5f  00000000  00000000  0002c310  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00009fa0  00000000  00000000  0004416f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00095c07  00000000  00000000  0004e10f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000050  00000000  00000000  000e3d16  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000356c  00000000  00000000  000e3d68  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000138 <__do_global_dtors_aux>:
 8000138:	b510      	push	{r4, lr}
 800013a:	4c05      	ldr	r4, [pc, #20]	; (8000150 <__do_global_dtors_aux+0x18>)
 800013c:	7823      	ldrb	r3, [r4, #0]
 800013e:	b933      	cbnz	r3, 800014e <__do_global_dtors_aux+0x16>
 8000140:	4b04      	ldr	r3, [pc, #16]	; (8000154 <__do_global_dtors_aux+0x1c>)
 8000142:	b113      	cbz	r3, 800014a <__do_global_dtors_aux+0x12>
 8000144:	4804      	ldr	r0, [pc, #16]	; (8000158 <__do_global_dtors_aux+0x20>)
 8000146:	f3af 8000 	nop.w
 800014a:	2301      	movs	r3, #1
 800014c:	7023      	strb	r3, [r4, #0]
 800014e:	bd10      	pop	{r4, pc}
 8000150:	2000000c 	.word	0x2000000c
 8000154:	00000000 	.word	0x00000000
 8000158:	08002a00 	.word	0x08002a00

0800015c <frame_dummy>:
 800015c:	b508      	push	{r3, lr}
 800015e:	4b03      	ldr	r3, [pc, #12]	; (800016c <frame_dummy+0x10>)
 8000160:	b11b      	cbz	r3, 800016a <frame_dummy+0xe>
 8000162:	4903      	ldr	r1, [pc, #12]	; (8000170 <frame_dummy+0x14>)
 8000164:	4803      	ldr	r0, [pc, #12]	; (8000174 <frame_dummy+0x18>)
 8000166:	f3af 8000 	nop.w
 800016a:	bd08      	pop	{r3, pc}
 800016c:	00000000 	.word	0x00000000
 8000170:	20000010 	.word	0x20000010
 8000174:	08002a00 	.word	0x08002a00

08000178 <LL_AHB2_GRP1_EnableClock>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOC
  *         @arg @ref LL_AHB2_GRP1_PERIPH_GPIOH
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
 8000178:	b480      	push	{r7}
 800017a:	b085      	sub	sp, #20
 800017c:	af00      	add	r7, sp, #0
 800017e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000180:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000184:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000186:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800018a:	687b      	ldr	r3, [r7, #4]
 800018c:	4313      	orrs	r3, r2
 800018e:	64cb      	str	r3, [r1, #76]	; 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000190:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000194:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000196:	687b      	ldr	r3, [r7, #4]
 8000198:	4013      	ands	r3, r2
 800019a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800019c:	68fb      	ldr	r3, [r7, #12]
}
 800019e:	bf00      	nop
 80001a0:	3714      	adds	r7, #20
 80001a2:	46bd      	mov	sp, r7
 80001a4:	bc80      	pop	{r7}
 80001a6:	4770      	bx	lr

080001a8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 80001a8:	b580      	push	{r7, lr}
 80001aa:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 80001ac:	f000 f990 	bl	80004d0 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 80001b0:	f000 f81a 	bl	80001e8 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 80001b4:	f000 f89a 	bl	80002ec <MX_GPIO_Init>
  MX_LPTIM1_Init();
 80001b8:	f000 f86c 	bl	8000294 <MX_LPTIM1_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
	LED_control(1);
 80001bc:	2001      	movs	r0, #1
 80001be:	f000 f8bb 	bl	8000338 <LED_control>
	HAL_LPTIM_Counter_Start_IT(&hlptim1,
 80001c2:	f44f 417a 	mov.w	r1, #64000	; 0xfa00
 80001c6:	4807      	ldr	r0, [pc, #28]	; (80001e4 <main+0x3c>)
 80001c8:	f000 fdd8 	bl	8000d7c <HAL_LPTIM_Counter_Start_IT>
				2000 * LSI_VALUE / 1000);
    HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 80001cc:	2001      	movs	r0, #1
 80001ce:	f001 f913 	bl	80013f8 <HAL_PWREx_EnterSTOP2Mode>
    LED_control(0);
 80001d2:	2000      	movs	r0, #0
 80001d4:	f000 f8b0 	bl	8000338 <LED_control>
    HAL_Delay(2000);
 80001d8:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80001dc:	f000 f9ee 	bl	80005bc <HAL_Delay>
	LED_control(1);
 80001e0:	e7ec      	b.n	80001bc <main+0x14>
 80001e2:	bf00      	nop
 80001e4:	20000028 	.word	0x20000028

080001e8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80001e8:	b580      	push	{r7, lr}
 80001ea:	b09a      	sub	sp, #104	; 0x68
 80001ec:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80001ee:	f107 0320 	add.w	r3, r7, #32
 80001f2:	2248      	movs	r2, #72	; 0x48
 80001f4:	2100      	movs	r1, #0
 80001f6:	4618      	mov	r0, r3
 80001f8:	f002 fbfa 	bl	80029f0 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80001fc:	f107 0308 	add.w	r3, r7, #8
 8000200:	2200      	movs	r2, #0
 8000202:	601a      	str	r2, [r3, #0]
 8000204:	605a      	str	r2, [r3, #4]
 8000206:	609a      	str	r2, [r3, #8]
 8000208:	60da      	str	r2, [r3, #12]
 800020a:	611a      	str	r2, [r3, #16]
 800020c:	615a      	str	r2, [r3, #20]

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 800020e:	4b20      	ldr	r3, [pc, #128]	; (8000290 <SystemClock_Config+0xa8>)
 8000210:	681b      	ldr	r3, [r3, #0]
 8000212:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8000216:	4a1e      	ldr	r2, [pc, #120]	; (8000290 <SystemClock_Config+0xa8>)
 8000218:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800021c:	6013      	str	r3, [r2, #0]
 800021e:	4b1c      	ldr	r3, [pc, #112]	; (8000290 <SystemClock_Config+0xa8>)
 8000220:	681b      	ldr	r3, [r3, #0]
 8000222:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000226:	607b      	str	r3, [r7, #4]
 8000228:	687b      	ldr	r3, [r7, #4]
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_MSI;
 800022a:	2328      	movs	r3, #40	; 0x28
 800022c:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800022e:	2301      	movs	r3, #1
 8000230:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 8000232:	2300      	movs	r3, #0
 8000234:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 8000236:	2360      	movs	r3, #96	; 0x60
 8000238:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
 800023a:	2300      	movs	r3, #0
 800023c:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800023e:	2301      	movs	r3, #1
 8000240:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8000242:	2300      	movs	r3, #0
 8000244:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000246:	f107 0320 	add.w	r3, r7, #32
 800024a:	4618      	mov	r0, r3
 800024c:	f001 fb78 	bl	8001940 <HAL_RCC_OscConfig>
 8000250:	4603      	mov	r3, r0
 8000252:	2b00      	cmp	r3, #0
 8000254:	d001      	beq.n	800025a <SystemClock_Config+0x72>
  {
    Error_Handler();
 8000256:	f000 f881 	bl	800035c <Error_Handler>
  }
  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 800025a:	234f      	movs	r3, #79	; 0x4f
 800025c:	60bb      	str	r3, [r7, #8]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 800025e:	2300      	movs	r3, #0
 8000260:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000262:	2300      	movs	r3, #0
 8000264:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000266:	2300      	movs	r3, #0
 8000268:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800026a:	2300      	movs	r3, #0
 800026c:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 800026e:	2300      	movs	r3, #0
 8000270:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000272:	f107 0308 	add.w	r3, r7, #8
 8000276:	2100      	movs	r1, #0
 8000278:	4618      	mov	r0, r3
 800027a:	f001 fefd 	bl	8002078 <HAL_RCC_ClockConfig>
 800027e:	4603      	mov	r3, r0
 8000280:	2b00      	cmp	r3, #0
 8000282:	d001      	beq.n	8000288 <SystemClock_Config+0xa0>
  {
    Error_Handler();
 8000284:	f000 f86a 	bl	800035c <Error_Handler>
  }
}
 8000288:	bf00      	nop
 800028a:	3768      	adds	r7, #104	; 0x68
 800028c:	46bd      	mov	sp, r7
 800028e:	bd80      	pop	{r7, pc}
 8000290:	58000400 	.word	0x58000400

08000294 <MX_LPTIM1_Init>:
  * @brief LPTIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_LPTIM1_Init(void)
{
 8000294:	b580      	push	{r7, lr}
 8000296:	af00      	add	r7, sp, #0
  /* USER CODE END LPTIM1_Init 0 */

  /* USER CODE BEGIN LPTIM1_Init 1 */

  /* USER CODE END LPTIM1_Init 1 */
  hlptim1.Instance = LPTIM1;
 8000298:	4b12      	ldr	r3, [pc, #72]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 800029a:	4a13      	ldr	r2, [pc, #76]	; (80002e8 <MX_LPTIM1_Init+0x54>)
 800029c:	601a      	str	r2, [r3, #0]
  hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
 800029e:	4b11      	ldr	r3, [pc, #68]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002a0:	2200      	movs	r2, #0
 80002a2:	605a      	str	r2, [r3, #4]
  hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
 80002a4:	4b0f      	ldr	r3, [pc, #60]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002a6:	2200      	movs	r2, #0
 80002a8:	609a      	str	r2, [r3, #8]
  hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
 80002aa:	4b0e      	ldr	r3, [pc, #56]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80002b0:	615a      	str	r2, [r3, #20]
  hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
 80002b2:	4b0c      	ldr	r3, [pc, #48]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002b4:	2200      	movs	r2, #0
 80002b6:	621a      	str	r2, [r3, #32]
  hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
 80002b8:	4b0a      	ldr	r3, [pc, #40]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002ba:	2200      	movs	r2, #0
 80002bc:	625a      	str	r2, [r3, #36]	; 0x24
  hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL;
 80002be:	4b09      	ldr	r3, [pc, #36]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002c0:	2200      	movs	r2, #0
 80002c2:	629a      	str	r2, [r3, #40]	; 0x28
  hlptim1.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO;
 80002c4:	4b07      	ldr	r3, [pc, #28]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002c6:	2200      	movs	r2, #0
 80002c8:	62da      	str	r2, [r3, #44]	; 0x2c
  hlptim1.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO;
 80002ca:	4b06      	ldr	r3, [pc, #24]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002cc:	2200      	movs	r2, #0
 80002ce:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_LPTIM_Init(&hlptim1) != HAL_OK)
 80002d0:	4804      	ldr	r0, [pc, #16]	; (80002e4 <MX_LPTIM1_Init+0x50>)
 80002d2:	f000 fc8b 	bl	8000bec <HAL_LPTIM_Init>
 80002d6:	4603      	mov	r3, r0
 80002d8:	2b00      	cmp	r3, #0
 80002da:	d001      	beq.n	80002e0 <MX_LPTIM1_Init+0x4c>
  {
    Error_Handler();
 80002dc:	f000 f83e 	bl	800035c <Error_Handler>
  }
  /* USER CODE BEGIN LPTIM1_Init 2 */

  /* USER CODE END LPTIM1_Init 2 */

}
 80002e0:	bf00      	nop
 80002e2:	bd80      	pop	{r7, pc}
 80002e4:	20000028 	.word	0x20000028
 80002e8:	40007c00 	.word	0x40007c00

080002ec <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80002ec:	b580      	push	{r7, lr}
 80002ee:	b086      	sub	sp, #24
 80002f0:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80002f2:	1d3b      	adds	r3, r7, #4
 80002f4:	2200      	movs	r2, #0
 80002f6:	601a      	str	r2, [r3, #0]
 80002f8:	605a      	str	r2, [r3, #4]
 80002fa:	609a      	str	r2, [r3, #8]
 80002fc:	60da      	str	r2, [r3, #12]
 80002fe:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000300:	2002      	movs	r0, #2
 8000302:	f7ff ff39 	bl	8000178 <LL_AHB2_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);
 8000306:	2200      	movs	r2, #0
 8000308:	2120      	movs	r1, #32
 800030a:	480a      	ldr	r0, [pc, #40]	; (8000334 <MX_GPIO_Init+0x48>)
 800030c:	f000 fbe6 	bl	8000adc <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PB5 */
  GPIO_InitStruct.Pin = GPIO_PIN_5;
 8000310:	2320      	movs	r3, #32
 8000312:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000314:	2301      	movs	r3, #1
 8000316:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000318:	2300      	movs	r3, #0
 800031a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800031c:	2300      	movs	r3, #0
 800031e:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000320:	1d3b      	adds	r3, r7, #4
 8000322:	4619      	mov	r1, r3
 8000324:	4803      	ldr	r0, [pc, #12]	; (8000334 <MX_GPIO_Init+0x48>)
 8000326:	f000 fa79 	bl	800081c <HAL_GPIO_Init>

}
 800032a:	bf00      	nop
 800032c:	3718      	adds	r7, #24
 800032e:	46bd      	mov	sp, r7
 8000330:	bd80      	pop	{r7, pc}
 8000332:	bf00      	nop
 8000334:	48000400 	.word	0x48000400

08000338 <LED_control>:

/* USER CODE BEGIN 4 */
int32_t LED_control(int value) {
 8000338:	b580      	push	{r7, lr}
 800033a:	b082      	sub	sp, #8
 800033c:	af00      	add	r7, sp, #0
 800033e:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, value);
 8000340:	687b      	ldr	r3, [r7, #4]
 8000342:	b2db      	uxtb	r3, r3
 8000344:	461a      	mov	r2, r3
 8000346:	2120      	movs	r1, #32
 8000348:	4803      	ldr	r0, [pc, #12]	; (8000358 <LED_control+0x20>)
 800034a:	f000 fbc7 	bl	8000adc <HAL_GPIO_WritePin>
  return 0;
 800034e:	2300      	movs	r3, #0
}
 8000350:	4618      	mov	r0, r3
 8000352:	3708      	adds	r7, #8
 8000354:	46bd      	mov	sp, r7
 8000356:	bd80      	pop	{r7, pc}
 8000358:	48000400 	.word	0x48000400

0800035c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800035c:	b480      	push	{r7}
 800035e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000360:	b672      	cpsid	i
}
 8000362:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000364:	e7fe      	b.n	8000364 <Error_Handler+0x8>

08000366 <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_DAC
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 8000366:	b480      	push	{r7}
 8000368:	b085      	sub	sp, #20
 800036a:	af00      	add	r7, sp, #0
 800036c:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 800036e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000372:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000374:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000378:	687b      	ldr	r3, [r7, #4]
 800037a:	4313      	orrs	r3, r2
 800037c:	658b      	str	r3, [r1, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800037e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000382:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000384:	687b      	ldr	r3, [r7, #4]
 8000386:	4013      	ands	r3, r2
 8000388:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 800038a:	68fb      	ldr	r3, [r7, #12]
}
 800038c:	bf00      	nop
 800038e:	3714      	adds	r7, #20
 8000390:	46bd      	mov	sp, r7
 8000392:	bc80      	pop	{r7}
 8000394:	4770      	bx	lr

08000396 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000396:	b480      	push	{r7}
 8000398:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800039a:	bf00      	nop
 800039c:	46bd      	mov	sp, r7
 800039e:	bc80      	pop	{r7}
 80003a0:	4770      	bx	lr
	...

080003a4 <HAL_LPTIM_MspInit>:
* This function configures the hardware resources used in this example
* @param hlptim: LPTIM handle pointer
* @retval None
*/
void HAL_LPTIM_MspInit(LPTIM_HandleTypeDef* hlptim)
{
 80003a4:	b580      	push	{r7, lr}
 80003a6:	b090      	sub	sp, #64	; 0x40
 80003a8:	af00      	add	r7, sp, #0
 80003aa:	6078      	str	r0, [r7, #4]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80003ac:	f107 0308 	add.w	r3, r7, #8
 80003b0:	2238      	movs	r2, #56	; 0x38
 80003b2:	2100      	movs	r1, #0
 80003b4:	4618      	mov	r0, r3
 80003b6:	f002 fb1b 	bl	80029f0 <memset>
  if(hlptim->Instance==LPTIM1)
 80003ba:	687b      	ldr	r3, [r7, #4]
 80003bc:	681b      	ldr	r3, [r3, #0]
 80003be:	4a11      	ldr	r2, [pc, #68]	; (8000404 <HAL_LPTIM_MspInit+0x60>)
 80003c0:	4293      	cmp	r3, r2
 80003c2:	d11a      	bne.n	80003fa <HAL_LPTIM_MspInit+0x56>
  /* USER CODE BEGIN LPTIM1_MspInit 0 */

  /* USER CODE END LPTIM1_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPTIM1;
 80003c4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80003c8:	60bb      	str	r3, [r7, #8]
    PeriphClkInitStruct.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_LSI;
 80003ca:	4b0f      	ldr	r3, [pc, #60]	; (8000408 <HAL_LPTIM_MspInit+0x64>)
 80003cc:	62bb      	str	r3, [r7, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80003ce:	f107 0308 	add.w	r3, r7, #8
 80003d2:	4618      	mov	r0, r3
 80003d4:	f002 f9ce 	bl	8002774 <HAL_RCCEx_PeriphCLKConfig>
 80003d8:	4603      	mov	r3, r0
 80003da:	2b00      	cmp	r3, #0
 80003dc:	d001      	beq.n	80003e2 <HAL_LPTIM_MspInit+0x3e>
    {
      Error_Handler();
 80003de:	f7ff ffbd 	bl	800035c <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 80003e2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80003e6:	f7ff ffbe 	bl	8000366 <LL_APB1_GRP1_EnableClock>
    /* LPTIM1 interrupt Init */
    HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 80003ea:	2200      	movs	r2, #0
 80003ec:	2100      	movs	r1, #0
 80003ee:	2027      	movs	r0, #39	; 0x27
 80003f0:	f000 f9df 	bl	80007b2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LPTIM1_IRQn);
 80003f4:	2027      	movs	r0, #39	; 0x27
 80003f6:	f000 f9f6 	bl	80007e6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN LPTIM1_MspInit 1 */

  /* USER CODE END LPTIM1_MspInit 1 */
  }

}
 80003fa:	bf00      	nop
 80003fc:	3740      	adds	r7, #64	; 0x40
 80003fe:	46bd      	mov	sp, r7
 8000400:	bd80      	pop	{r7, pc}
 8000402:	bf00      	nop
 8000404:	40007c00 	.word	0x40007c00
 8000408:	000c0004 	.word	0x000c0004

0800040c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800040c:	b480      	push	{r7}
 800040e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8000410:	e7fe      	b.n	8000410 <NMI_Handler+0x4>

08000412 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000412:	b480      	push	{r7}
 8000414:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000416:	e7fe      	b.n	8000416 <HardFault_Handler+0x4>

08000418 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000418:	b480      	push	{r7}
 800041a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800041c:	e7fe      	b.n	800041c <MemManage_Handler+0x4>

0800041e <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800041e:	b480      	push	{r7}
 8000420:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8000422:	e7fe      	b.n	8000422 <BusFault_Handler+0x4>

08000424 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000424:	b480      	push	{r7}
 8000426:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8000428:	e7fe      	b.n	8000428 <UsageFault_Handler+0x4>

0800042a <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800042a:	b480      	push	{r7}
 800042c:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800042e:	bf00      	nop
 8000430:	46bd      	mov	sp, r7
 8000432:	bc80      	pop	{r7}
 8000434:	4770      	bx	lr

08000436 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8000436:	b480      	push	{r7}
 8000438:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800043a:	bf00      	nop
 800043c:	46bd      	mov	sp, r7
 800043e:	bc80      	pop	{r7}
 8000440:	4770      	bx	lr

08000442 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8000442:	b480      	push	{r7}
 8000444:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8000446:	bf00      	nop
 8000448:	46bd      	mov	sp, r7
 800044a:	bc80      	pop	{r7}
 800044c:	4770      	bx	lr

0800044e <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800044e:	b580      	push	{r7, lr}
 8000450:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000452:	f000 f897 	bl	8000584 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8000456:	bf00      	nop
 8000458:	bd80      	pop	{r7, pc}
	...

0800045c <LPTIM1_IRQHandler>:

/**
  * @brief This function handles LPTIM1 Global Interrupt.
  */
void LPTIM1_IRQHandler(void)
{
 800045c:	b580      	push	{r7, lr}
 800045e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN LPTIM1_IRQn 0 */

  /* USER CODE END LPTIM1_IRQn 0 */
  HAL_LPTIM_IRQHandler(&hlptim1);
 8000460:	4802      	ldr	r0, [pc, #8]	; (800046c <LPTIM1_IRQHandler+0x10>)
 8000462:	f000 fd2d 	bl	8000ec0 <HAL_LPTIM_IRQHandler>
  /* USER CODE BEGIN LPTIM1_IRQn 1 */

  /* USER CODE END LPTIM1_IRQn 1 */
}
 8000466:	bf00      	nop
 8000468:	bd80      	pop	{r7, pc}
 800046a:	bf00      	nop
 800046c:	20000028 	.word	0x20000028

08000470 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000470:	b480      	push	{r7}
 8000472:	af00      	add	r7, sp, #0

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8000474:	bf00      	nop
 8000476:	46bd      	mov	sp, r7
 8000478:	bc80      	pop	{r7}
 800047a:	4770      	bx	lr

0800047c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800047c:	480d      	ldr	r0, [pc, #52]	; (80004b4 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800047e:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 8000480:	f7ff fff6 	bl	8000470 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000484:	480c      	ldr	r0, [pc, #48]	; (80004b8 <LoopForever+0x6>)
  ldr r1, =_edata
 8000486:	490d      	ldr	r1, [pc, #52]	; (80004bc <LoopForever+0xa>)
  ldr r2, =_sidata
 8000488:	4a0d      	ldr	r2, [pc, #52]	; (80004c0 <LoopForever+0xe>)
  movs r3, #0
 800048a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 800048c:	e002      	b.n	8000494 <LoopCopyDataInit>

0800048e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800048e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000490:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000492:	3304      	adds	r3, #4

08000494 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000494:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000496:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000498:	d3f9      	bcc.n	800048e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800049a:	4a0a      	ldr	r2, [pc, #40]	; (80004c4 <LoopForever+0x12>)
  ldr r4, =_ebss
 800049c:	4c0a      	ldr	r4, [pc, #40]	; (80004c8 <LoopForever+0x16>)
  movs r3, #0
 800049e:	2300      	movs	r3, #0
  b LoopFillZerobss
 80004a0:	e001      	b.n	80004a6 <LoopFillZerobss>

080004a2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80004a2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80004a4:	3204      	adds	r2, #4

080004a6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80004a6:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80004a8:	d3fb      	bcc.n	80004a2 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80004aa:	f002 fa7d 	bl	80029a8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80004ae:	f7ff fe7b 	bl	80001a8 <main>

080004b2 <LoopForever>:

LoopForever:
    b LoopForever
 80004b2:	e7fe      	b.n	80004b2 <LoopForever>
  ldr   r0, =_estack
 80004b4:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 80004b8:	20000000 	.word	0x20000000
  ldr r1, =_edata
 80004bc:	2000000c 	.word	0x2000000c
  ldr r2, =_sidata
 80004c0:	08002abc 	.word	0x08002abc
  ldr r2, =_sbss
 80004c4:	2000000c 	.word	0x2000000c
  ldr r4, =_ebss
 80004c8:	20000068 	.word	0x20000068

080004cc <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80004cc:	e7fe      	b.n	80004cc <ADC_IRQHandler>
	...

080004d0 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80004d0:	b580      	push	{r7, lr}
 80004d2:	b082      	sub	sp, #8
 80004d4:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80004d6:	2300      	movs	r3, #0
 80004d8:	71fb      	strb	r3, [r7, #7]
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80004da:	2003      	movs	r0, #3
 80004dc:	f000 f95e 	bl	800079c <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80004e0:	f001 ff8e 	bl	8002400 <HAL_RCC_GetHCLKFreq>
 80004e4:	4603      	mov	r3, r0
 80004e6:	4a09      	ldr	r2, [pc, #36]	; (800050c <HAL_Init+0x3c>)
 80004e8:	6013      	str	r3, [r2, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80004ea:	200f      	movs	r0, #15
 80004ec:	f000 f810 	bl	8000510 <HAL_InitTick>
 80004f0:	4603      	mov	r3, r0
 80004f2:	2b00      	cmp	r3, #0
 80004f4:	d002      	beq.n	80004fc <HAL_Init+0x2c>
  {
    status = HAL_ERROR;
 80004f6:	2301      	movs	r3, #1
 80004f8:	71fb      	strb	r3, [r7, #7]
 80004fa:	e001      	b.n	8000500 <HAL_Init+0x30>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80004fc:	f7ff ff4b 	bl	8000396 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 8000500:	79fb      	ldrb	r3, [r7, #7]
}
 8000502:	4618      	mov	r0, r3
 8000504:	3708      	adds	r7, #8
 8000506:	46bd      	mov	sp, r7
 8000508:	bd80      	pop	{r7, pc}
 800050a:	bf00      	nop
 800050c:	20000000 	.word	0x20000000

08000510 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000510:	b580      	push	{r7, lr}
 8000512:	b084      	sub	sp, #16
 8000514:	af00      	add	r7, sp, #0
 8000516:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 8000518:	2300      	movs	r3, #0
 800051a:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 800051c:	4b17      	ldr	r3, [pc, #92]	; (800057c <HAL_InitTick+0x6c>)
 800051e:	781b      	ldrb	r3, [r3, #0]
 8000520:	2b00      	cmp	r3, #0
 8000522:	d024      	beq.n	800056e <HAL_InitTick+0x5e>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
#ifdef CORE_CM0PLUS
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLK2Freq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
#else
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 8000524:	f001 ff6c 	bl	8002400 <HAL_RCC_GetHCLKFreq>
 8000528:	4602      	mov	r2, r0
 800052a:	4b14      	ldr	r3, [pc, #80]	; (800057c <HAL_InitTick+0x6c>)
 800052c:	781b      	ldrb	r3, [r3, #0]
 800052e:	4619      	mov	r1, r3
 8000530:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000534:	fbb3 f3f1 	udiv	r3, r3, r1
 8000538:	fbb2 f3f3 	udiv	r3, r2, r3
 800053c:	4618      	mov	r0, r3
 800053e:	f000 f960 	bl	8000802 <HAL_SYSTICK_Config>
 8000542:	4603      	mov	r3, r0
 8000544:	2b00      	cmp	r3, #0
 8000546:	d10f      	bne.n	8000568 <HAL_InitTick+0x58>
#endif
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000548:	687b      	ldr	r3, [r7, #4]
 800054a:	2b0f      	cmp	r3, #15
 800054c:	d809      	bhi.n	8000562 <HAL_InitTick+0x52>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800054e:	2200      	movs	r2, #0
 8000550:	6879      	ldr	r1, [r7, #4]
 8000552:	f04f 30ff 	mov.w	r0, #4294967295
 8000556:	f000 f92c 	bl	80007b2 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800055a:	4a09      	ldr	r2, [pc, #36]	; (8000580 <HAL_InitTick+0x70>)
 800055c:	687b      	ldr	r3, [r7, #4]
 800055e:	6013      	str	r3, [r2, #0]
 8000560:	e007      	b.n	8000572 <HAL_InitTick+0x62>
      }
      else
      {
        status = HAL_ERROR;
 8000562:	2301      	movs	r3, #1
 8000564:	73fb      	strb	r3, [r7, #15]
 8000566:	e004      	b.n	8000572 <HAL_InitTick+0x62>
      }
    }
    else
    {
      status = HAL_ERROR;
 8000568:	2301      	movs	r3, #1
 800056a:	73fb      	strb	r3, [r7, #15]
 800056c:	e001      	b.n	8000572 <HAL_InitTick+0x62>
    }
  }
  else
  {
    status = HAL_ERROR;
 800056e:	2301      	movs	r3, #1
 8000570:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
 8000572:	7bfb      	ldrb	r3, [r7, #15]
}
 8000574:	4618      	mov	r0, r3
 8000576:	3710      	adds	r7, #16
 8000578:	46bd      	mov	sp, r7
 800057a:	bd80      	pop	{r7, pc}
 800057c:	20000008 	.word	0x20000008
 8000580:	20000004 	.word	0x20000004

08000584 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000584:	b480      	push	{r7}
 8000586:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8000588:	4b05      	ldr	r3, [pc, #20]	; (80005a0 <HAL_IncTick+0x1c>)
 800058a:	781b      	ldrb	r3, [r3, #0]
 800058c:	461a      	mov	r2, r3
 800058e:	4b05      	ldr	r3, [pc, #20]	; (80005a4 <HAL_IncTick+0x20>)
 8000590:	681b      	ldr	r3, [r3, #0]
 8000592:	4413      	add	r3, r2
 8000594:	4a03      	ldr	r2, [pc, #12]	; (80005a4 <HAL_IncTick+0x20>)
 8000596:	6013      	str	r3, [r2, #0]
}
 8000598:	bf00      	nop
 800059a:	46bd      	mov	sp, r7
 800059c:	bc80      	pop	{r7}
 800059e:	4770      	bx	lr
 80005a0:	20000008 	.word	0x20000008
 80005a4:	20000064 	.word	0x20000064

080005a8 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 80005a8:	b480      	push	{r7}
 80005aa:	af00      	add	r7, sp, #0
  return uwTick;
 80005ac:	4b02      	ldr	r3, [pc, #8]	; (80005b8 <HAL_GetTick+0x10>)
 80005ae:	681b      	ldr	r3, [r3, #0]
}
 80005b0:	4618      	mov	r0, r3
 80005b2:	46bd      	mov	sp, r7
 80005b4:	bc80      	pop	{r7}
 80005b6:	4770      	bx	lr
 80005b8:	20000064 	.word	0x20000064

080005bc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80005bc:	b580      	push	{r7, lr}
 80005be:	b084      	sub	sp, #16
 80005c0:	af00      	add	r7, sp, #0
 80005c2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 80005c4:	f7ff fff0 	bl	80005a8 <HAL_GetTick>
 80005c8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 80005ca:	687b      	ldr	r3, [r7, #4]
 80005cc:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80005ce:	68fb      	ldr	r3, [r7, #12]
 80005d0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80005d4:	d005      	beq.n	80005e2 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 80005d6:	4b0a      	ldr	r3, [pc, #40]	; (8000600 <HAL_Delay+0x44>)
 80005d8:	781b      	ldrb	r3, [r3, #0]
 80005da:	461a      	mov	r2, r3
 80005dc:	68fb      	ldr	r3, [r7, #12]
 80005de:	4413      	add	r3, r2
 80005e0:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80005e2:	bf00      	nop
 80005e4:	f7ff ffe0 	bl	80005a8 <HAL_GetTick>
 80005e8:	4602      	mov	r2, r0
 80005ea:	68bb      	ldr	r3, [r7, #8]
 80005ec:	1ad3      	subs	r3, r2, r3
 80005ee:	68fa      	ldr	r2, [r7, #12]
 80005f0:	429a      	cmp	r2, r3
 80005f2:	d8f7      	bhi.n	80005e4 <HAL_Delay+0x28>
  {
  }
}
 80005f4:	bf00      	nop
 80005f6:	bf00      	nop
 80005f8:	3710      	adds	r7, #16
 80005fa:	46bd      	mov	sp, r7
 80005fc:	bd80      	pop	{r7, pc}
 80005fe:	bf00      	nop
 8000600:	20000008 	.word	0x20000008

08000604 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000604:	b480      	push	{r7}
 8000606:	b085      	sub	sp, #20
 8000608:	af00      	add	r7, sp, #0
 800060a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800060c:	687b      	ldr	r3, [r7, #4]
 800060e:	f003 0307 	and.w	r3, r3, #7
 8000612:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000614:	4b0c      	ldr	r3, [pc, #48]	; (8000648 <__NVIC_SetPriorityGrouping+0x44>)
 8000616:	68db      	ldr	r3, [r3, #12]
 8000618:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800061a:	68ba      	ldr	r2, [r7, #8]
 800061c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000620:	4013      	ands	r3, r2
 8000622:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000624:	68fb      	ldr	r3, [r7, #12]
 8000626:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000628:	68bb      	ldr	r3, [r7, #8]
 800062a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800062c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000630:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000634:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8000636:	4a04      	ldr	r2, [pc, #16]	; (8000648 <__NVIC_SetPriorityGrouping+0x44>)
 8000638:	68bb      	ldr	r3, [r7, #8]
 800063a:	60d3      	str	r3, [r2, #12]
}
 800063c:	bf00      	nop
 800063e:	3714      	adds	r7, #20
 8000640:	46bd      	mov	sp, r7
 8000642:	bc80      	pop	{r7}
 8000644:	4770      	bx	lr
 8000646:	bf00      	nop
 8000648:	e000ed00 	.word	0xe000ed00

0800064c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800064c:	b480      	push	{r7}
 800064e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000650:	4b04      	ldr	r3, [pc, #16]	; (8000664 <__NVIC_GetPriorityGrouping+0x18>)
 8000652:	68db      	ldr	r3, [r3, #12]
 8000654:	0a1b      	lsrs	r3, r3, #8
 8000656:	f003 0307 	and.w	r3, r3, #7
}
 800065a:	4618      	mov	r0, r3
 800065c:	46bd      	mov	sp, r7
 800065e:	bc80      	pop	{r7}
 8000660:	4770      	bx	lr
 8000662:	bf00      	nop
 8000664:	e000ed00 	.word	0xe000ed00

08000668 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000668:	b480      	push	{r7}
 800066a:	b083      	sub	sp, #12
 800066c:	af00      	add	r7, sp, #0
 800066e:	4603      	mov	r3, r0
 8000670:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8000672:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000676:	2b00      	cmp	r3, #0
 8000678:	db0b      	blt.n	8000692 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800067a:	79fb      	ldrb	r3, [r7, #7]
 800067c:	f003 021f 	and.w	r2, r3, #31
 8000680:	4906      	ldr	r1, [pc, #24]	; (800069c <__NVIC_EnableIRQ+0x34>)
 8000682:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000686:	095b      	lsrs	r3, r3, #5
 8000688:	2001      	movs	r0, #1
 800068a:	fa00 f202 	lsl.w	r2, r0, r2
 800068e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8000692:	bf00      	nop
 8000694:	370c      	adds	r7, #12
 8000696:	46bd      	mov	sp, r7
 8000698:	bc80      	pop	{r7}
 800069a:	4770      	bx	lr
 800069c:	e000e100 	.word	0xe000e100

080006a0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80006a0:	b480      	push	{r7}
 80006a2:	b083      	sub	sp, #12
 80006a4:	af00      	add	r7, sp, #0
 80006a6:	4603      	mov	r3, r0
 80006a8:	6039      	str	r1, [r7, #0]
 80006aa:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80006ac:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80006b0:	2b00      	cmp	r3, #0
 80006b2:	db0a      	blt.n	80006ca <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006b4:	683b      	ldr	r3, [r7, #0]
 80006b6:	b2da      	uxtb	r2, r3
 80006b8:	490c      	ldr	r1, [pc, #48]	; (80006ec <__NVIC_SetPriority+0x4c>)
 80006ba:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80006be:	0112      	lsls	r2, r2, #4
 80006c0:	b2d2      	uxtb	r2, r2
 80006c2:	440b      	add	r3, r1
 80006c4:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 80006c8:	e00a      	b.n	80006e0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80006ca:	683b      	ldr	r3, [r7, #0]
 80006cc:	b2da      	uxtb	r2, r3
 80006ce:	4908      	ldr	r1, [pc, #32]	; (80006f0 <__NVIC_SetPriority+0x50>)
 80006d0:	79fb      	ldrb	r3, [r7, #7]
 80006d2:	f003 030f 	and.w	r3, r3, #15
 80006d6:	3b04      	subs	r3, #4
 80006d8:	0112      	lsls	r2, r2, #4
 80006da:	b2d2      	uxtb	r2, r2
 80006dc:	440b      	add	r3, r1
 80006de:	761a      	strb	r2, [r3, #24]
}
 80006e0:	bf00      	nop
 80006e2:	370c      	adds	r7, #12
 80006e4:	46bd      	mov	sp, r7
 80006e6:	bc80      	pop	{r7}
 80006e8:	4770      	bx	lr
 80006ea:	bf00      	nop
 80006ec:	e000e100 	.word	0xe000e100
 80006f0:	e000ed00 	.word	0xe000ed00

080006f4 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80006f4:	b480      	push	{r7}
 80006f6:	b089      	sub	sp, #36	; 0x24
 80006f8:	af00      	add	r7, sp, #0
 80006fa:	60f8      	str	r0, [r7, #12]
 80006fc:	60b9      	str	r1, [r7, #8]
 80006fe:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000700:	68fb      	ldr	r3, [r7, #12]
 8000702:	f003 0307 	and.w	r3, r3, #7
 8000706:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000708:	69fb      	ldr	r3, [r7, #28]
 800070a:	f1c3 0307 	rsb	r3, r3, #7
 800070e:	2b04      	cmp	r3, #4
 8000710:	bf28      	it	cs
 8000712:	2304      	movcs	r3, #4
 8000714:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000716:	69fb      	ldr	r3, [r7, #28]
 8000718:	3304      	adds	r3, #4
 800071a:	2b06      	cmp	r3, #6
 800071c:	d902      	bls.n	8000724 <NVIC_EncodePriority+0x30>
 800071e:	69fb      	ldr	r3, [r7, #28]
 8000720:	3b03      	subs	r3, #3
 8000722:	e000      	b.n	8000726 <NVIC_EncodePriority+0x32>
 8000724:	2300      	movs	r3, #0
 8000726:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000728:	f04f 32ff 	mov.w	r2, #4294967295
 800072c:	69bb      	ldr	r3, [r7, #24]
 800072e:	fa02 f303 	lsl.w	r3, r2, r3
 8000732:	43da      	mvns	r2, r3
 8000734:	68bb      	ldr	r3, [r7, #8]
 8000736:	401a      	ands	r2, r3
 8000738:	697b      	ldr	r3, [r7, #20]
 800073a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800073c:	f04f 31ff 	mov.w	r1, #4294967295
 8000740:	697b      	ldr	r3, [r7, #20]
 8000742:	fa01 f303 	lsl.w	r3, r1, r3
 8000746:	43d9      	mvns	r1, r3
 8000748:	687b      	ldr	r3, [r7, #4]
 800074a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800074c:	4313      	orrs	r3, r2
         );
}
 800074e:	4618      	mov	r0, r3
 8000750:	3724      	adds	r7, #36	; 0x24
 8000752:	46bd      	mov	sp, r7
 8000754:	bc80      	pop	{r7}
 8000756:	4770      	bx	lr

08000758 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8000758:	b580      	push	{r7, lr}
 800075a:	b082      	sub	sp, #8
 800075c:	af00      	add	r7, sp, #0
 800075e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000760:	687b      	ldr	r3, [r7, #4]
 8000762:	3b01      	subs	r3, #1
 8000764:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8000768:	d301      	bcc.n	800076e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 800076a:	2301      	movs	r3, #1
 800076c:	e00f      	b.n	800078e <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800076e:	4a0a      	ldr	r2, [pc, #40]	; (8000798 <SysTick_Config+0x40>)
 8000770:	687b      	ldr	r3, [r7, #4]
 8000772:	3b01      	subs	r3, #1
 8000774:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8000776:	210f      	movs	r1, #15
 8000778:	f04f 30ff 	mov.w	r0, #4294967295
 800077c:	f7ff ff90 	bl	80006a0 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000780:	4b05      	ldr	r3, [pc, #20]	; (8000798 <SysTick_Config+0x40>)
 8000782:	2200      	movs	r2, #0
 8000784:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000786:	4b04      	ldr	r3, [pc, #16]	; (8000798 <SysTick_Config+0x40>)
 8000788:	2207      	movs	r2, #7
 800078a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800078c:	2300      	movs	r3, #0
}
 800078e:	4618      	mov	r0, r3
 8000790:	3708      	adds	r7, #8
 8000792:	46bd      	mov	sp, r7
 8000794:	bd80      	pop	{r7, pc}
 8000796:	bf00      	nop
 8000798:	e000e010 	.word	0xe000e010

0800079c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800079c:	b580      	push	{r7, lr}
 800079e:	b082      	sub	sp, #8
 80007a0:	af00      	add	r7, sp, #0
 80007a2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80007a4:	6878      	ldr	r0, [r7, #4]
 80007a6:	f7ff ff2d 	bl	8000604 <__NVIC_SetPriorityGrouping>
}
 80007aa:	bf00      	nop
 80007ac:	3708      	adds	r7, #8
 80007ae:	46bd      	mov	sp, r7
 80007b0:	bd80      	pop	{r7, pc}

080007b2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80007b2:	b580      	push	{r7, lr}
 80007b4:	b086      	sub	sp, #24
 80007b6:	af00      	add	r7, sp, #0
 80007b8:	4603      	mov	r3, r0
 80007ba:	60b9      	str	r1, [r7, #8]
 80007bc:	607a      	str	r2, [r7, #4]
 80007be:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 80007c0:	f7ff ff44 	bl	800064c <__NVIC_GetPriorityGrouping>
 80007c4:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80007c6:	687a      	ldr	r2, [r7, #4]
 80007c8:	68b9      	ldr	r1, [r7, #8]
 80007ca:	6978      	ldr	r0, [r7, #20]
 80007cc:	f7ff ff92 	bl	80006f4 <NVIC_EncodePriority>
 80007d0:	4602      	mov	r2, r0
 80007d2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80007d6:	4611      	mov	r1, r2
 80007d8:	4618      	mov	r0, r3
 80007da:	f7ff ff61 	bl	80006a0 <__NVIC_SetPriority>
}
 80007de:	bf00      	nop
 80007e0:	3718      	adds	r7, #24
 80007e2:	46bd      	mov	sp, r7
 80007e4:	bd80      	pop	{r7, pc}

080007e6 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *          to the appropriate CMSIS device file (stm32wlxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80007e6:	b580      	push	{r7, lr}
 80007e8:	b082      	sub	sp, #8
 80007ea:	af00      	add	r7, sp, #0
 80007ec:	4603      	mov	r3, r0
 80007ee:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80007f0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80007f4:	4618      	mov	r0, r3
 80007f6:	f7ff ff37 	bl	8000668 <__NVIC_EnableIRQ>
}
 80007fa:	bf00      	nop
 80007fc:	3708      	adds	r7, #8
 80007fe:	46bd      	mov	sp, r7
 8000800:	bd80      	pop	{r7, pc}

08000802 <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000802:	b580      	push	{r7, lr}
 8000804:	b082      	sub	sp, #8
 8000806:	af00      	add	r7, sp, #0
 8000808:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 800080a:	6878      	ldr	r0, [r7, #4]
 800080c:	f7ff ffa4 	bl	8000758 <SysTick_Config>
 8000810:	4603      	mov	r3, r0
}
 8000812:	4618      	mov	r0, r3
 8000814:	3708      	adds	r7, #8
 8000816:	46bd      	mov	sp, r7
 8000818:	bd80      	pop	{r7, pc}
	...

0800081c <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800081c:	b480      	push	{r7}
 800081e:	b087      	sub	sp, #28
 8000820:	af00      	add	r7, sp, #0
 8000822:	6078      	str	r0, [r7, #4]
 8000824:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8000826:	2300      	movs	r3, #0
 8000828:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800082a:	e140      	b.n	8000aae <HAL_GPIO_Init+0x292>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800082c:	683b      	ldr	r3, [r7, #0]
 800082e:	681a      	ldr	r2, [r3, #0]
 8000830:	2101      	movs	r1, #1
 8000832:	697b      	ldr	r3, [r7, #20]
 8000834:	fa01 f303 	lsl.w	r3, r1, r3
 8000838:	4013      	ands	r3, r2
 800083a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 800083c:	68fb      	ldr	r3, [r7, #12]
 800083e:	2b00      	cmp	r3, #0
 8000840:	f000 8132 	beq.w	8000aa8 <HAL_GPIO_Init+0x28c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8000844:	683b      	ldr	r3, [r7, #0]
 8000846:	685b      	ldr	r3, [r3, #4]
 8000848:	f003 0303 	and.w	r3, r3, #3
 800084c:	2b01      	cmp	r3, #1
 800084e:	d005      	beq.n	800085c <HAL_GPIO_Init+0x40>
 8000850:	683b      	ldr	r3, [r7, #0]
 8000852:	685b      	ldr	r3, [r3, #4]
 8000854:	f003 0303 	and.w	r3, r3, #3
 8000858:	2b02      	cmp	r3, #2
 800085a:	d130      	bne.n	80008be <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 800085c:	687b      	ldr	r3, [r7, #4]
 800085e:	689b      	ldr	r3, [r3, #8]
 8000860:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8000862:	697b      	ldr	r3, [r7, #20]
 8000864:	005b      	lsls	r3, r3, #1
 8000866:	2203      	movs	r2, #3
 8000868:	fa02 f303 	lsl.w	r3, r2, r3
 800086c:	43db      	mvns	r3, r3
 800086e:	693a      	ldr	r2, [r7, #16]
 8000870:	4013      	ands	r3, r2
 8000872:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000874:	683b      	ldr	r3, [r7, #0]
 8000876:	68da      	ldr	r2, [r3, #12]
 8000878:	697b      	ldr	r3, [r7, #20]
 800087a:	005b      	lsls	r3, r3, #1
 800087c:	fa02 f303 	lsl.w	r3, r2, r3
 8000880:	693a      	ldr	r2, [r7, #16]
 8000882:	4313      	orrs	r3, r2
 8000884:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 8000886:	687b      	ldr	r3, [r7, #4]
 8000888:	693a      	ldr	r2, [r7, #16]
 800088a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 800088c:	687b      	ldr	r3, [r7, #4]
 800088e:	685b      	ldr	r3, [r3, #4]
 8000890:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000892:	2201      	movs	r2, #1
 8000894:	697b      	ldr	r3, [r7, #20]
 8000896:	fa02 f303 	lsl.w	r3, r2, r3
 800089a:	43db      	mvns	r3, r3
 800089c:	693a      	ldr	r2, [r7, #16]
 800089e:	4013      	ands	r3, r2
 80008a0:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80008a2:	683b      	ldr	r3, [r7, #0]
 80008a4:	685b      	ldr	r3, [r3, #4]
 80008a6:	091b      	lsrs	r3, r3, #4
 80008a8:	f003 0201 	and.w	r2, r3, #1
 80008ac:	697b      	ldr	r3, [r7, #20]
 80008ae:	fa02 f303 	lsl.w	r3, r2, r3
 80008b2:	693a      	ldr	r2, [r7, #16]
 80008b4:	4313      	orrs	r3, r2
 80008b6:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 80008b8:	687b      	ldr	r3, [r7, #4]
 80008ba:	693a      	ldr	r2, [r7, #16]
 80008bc:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80008be:	683b      	ldr	r3, [r7, #0]
 80008c0:	685b      	ldr	r3, [r3, #4]
 80008c2:	f003 0303 	and.w	r3, r3, #3
 80008c6:	2b03      	cmp	r3, #3
 80008c8:	d017      	beq.n	80008fa <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
 80008ca:	687b      	ldr	r3, [r7, #4]
 80008cc:	68db      	ldr	r3, [r3, #12]
 80008ce:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80008d0:	697b      	ldr	r3, [r7, #20]
 80008d2:	005b      	lsls	r3, r3, #1
 80008d4:	2203      	movs	r2, #3
 80008d6:	fa02 f303 	lsl.w	r3, r2, r3
 80008da:	43db      	mvns	r3, r3
 80008dc:	693a      	ldr	r2, [r7, #16]
 80008de:	4013      	ands	r3, r2
 80008e0:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 80008e2:	683b      	ldr	r3, [r7, #0]
 80008e4:	689a      	ldr	r2, [r3, #8]
 80008e6:	697b      	ldr	r3, [r7, #20]
 80008e8:	005b      	lsls	r3, r3, #1
 80008ea:	fa02 f303 	lsl.w	r3, r2, r3
 80008ee:	693a      	ldr	r2, [r7, #16]
 80008f0:	4313      	orrs	r3, r2
 80008f2:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 80008f4:	687b      	ldr	r3, [r7, #4]
 80008f6:	693a      	ldr	r2, [r7, #16]
 80008f8:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80008fa:	683b      	ldr	r3, [r7, #0]
 80008fc:	685b      	ldr	r3, [r3, #4]
 80008fe:	f003 0303 	and.w	r3, r3, #3
 8000902:	2b02      	cmp	r3, #2
 8000904:	d123      	bne.n	800094e <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8000906:	697b      	ldr	r3, [r7, #20]
 8000908:	08da      	lsrs	r2, r3, #3
 800090a:	687b      	ldr	r3, [r7, #4]
 800090c:	3208      	adds	r2, #8
 800090e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000912:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8000914:	697b      	ldr	r3, [r7, #20]
 8000916:	f003 0307 	and.w	r3, r3, #7
 800091a:	009b      	lsls	r3, r3, #2
 800091c:	220f      	movs	r2, #15
 800091e:	fa02 f303 	lsl.w	r3, r2, r3
 8000922:	43db      	mvns	r3, r3
 8000924:	693a      	ldr	r2, [r7, #16]
 8000926:	4013      	ands	r3, r2
 8000928:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800092a:	683b      	ldr	r3, [r7, #0]
 800092c:	691a      	ldr	r2, [r3, #16]
 800092e:	697b      	ldr	r3, [r7, #20]
 8000930:	f003 0307 	and.w	r3, r3, #7
 8000934:	009b      	lsls	r3, r3, #2
 8000936:	fa02 f303 	lsl.w	r3, r2, r3
 800093a:	693a      	ldr	r2, [r7, #16]
 800093c:	4313      	orrs	r3, r2
 800093e:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 8000940:	697b      	ldr	r3, [r7, #20]
 8000942:	08da      	lsrs	r2, r3, #3
 8000944:	687b      	ldr	r3, [r7, #4]
 8000946:	3208      	adds	r2, #8
 8000948:	6939      	ldr	r1, [r7, #16]
 800094a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800094e:	687b      	ldr	r3, [r7, #4]
 8000950:	681b      	ldr	r3, [r3, #0]
 8000952:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8000954:	697b      	ldr	r3, [r7, #20]
 8000956:	005b      	lsls	r3, r3, #1
 8000958:	2203      	movs	r2, #3
 800095a:	fa02 f303 	lsl.w	r3, r2, r3
 800095e:	43db      	mvns	r3, r3
 8000960:	693a      	ldr	r2, [r7, #16]
 8000962:	4013      	ands	r3, r2
 8000964:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000966:	683b      	ldr	r3, [r7, #0]
 8000968:	685b      	ldr	r3, [r3, #4]
 800096a:	f003 0203 	and.w	r2, r3, #3
 800096e:	697b      	ldr	r3, [r7, #20]
 8000970:	005b      	lsls	r3, r3, #1
 8000972:	fa02 f303 	lsl.w	r3, r2, r3
 8000976:	693a      	ldr	r2, [r7, #16]
 8000978:	4313      	orrs	r3, r2
 800097a:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 800097c:	687b      	ldr	r3, [r7, #4]
 800097e:	693a      	ldr	r2, [r7, #16]
 8000980:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8000982:	683b      	ldr	r3, [r7, #0]
 8000984:	685b      	ldr	r3, [r3, #4]
 8000986:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800098a:	2b00      	cmp	r3, #0
 800098c:	f000 808c 	beq.w	8000aa8 <HAL_GPIO_Init+0x28c>
      {
        temp = SYSCFG->EXTICR[position >> 2u];
 8000990:	4a4e      	ldr	r2, [pc, #312]	; (8000acc <HAL_GPIO_Init+0x2b0>)
 8000992:	697b      	ldr	r3, [r7, #20]
 8000994:	089b      	lsrs	r3, r3, #2
 8000996:	3302      	adds	r3, #2
 8000998:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800099c:	613b      	str	r3, [r7, #16]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 800099e:	697b      	ldr	r3, [r7, #20]
 80009a0:	f003 0303 	and.w	r3, r3, #3
 80009a4:	009b      	lsls	r3, r3, #2
 80009a6:	2207      	movs	r2, #7
 80009a8:	fa02 f303 	lsl.w	r3, r2, r3
 80009ac:	43db      	mvns	r3, r3
 80009ae:	693a      	ldr	r2, [r7, #16]
 80009b0:	4013      	ands	r3, r2
 80009b2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80009b4:	687b      	ldr	r3, [r7, #4]
 80009b6:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 80009ba:	d00d      	beq.n	80009d8 <HAL_GPIO_Init+0x1bc>
 80009bc:	687b      	ldr	r3, [r7, #4]
 80009be:	4a44      	ldr	r2, [pc, #272]	; (8000ad0 <HAL_GPIO_Init+0x2b4>)
 80009c0:	4293      	cmp	r3, r2
 80009c2:	d007      	beq.n	80009d4 <HAL_GPIO_Init+0x1b8>
 80009c4:	687b      	ldr	r3, [r7, #4]
 80009c6:	4a43      	ldr	r2, [pc, #268]	; (8000ad4 <HAL_GPIO_Init+0x2b8>)
 80009c8:	4293      	cmp	r3, r2
 80009ca:	d101      	bne.n	80009d0 <HAL_GPIO_Init+0x1b4>
 80009cc:	2302      	movs	r3, #2
 80009ce:	e004      	b.n	80009da <HAL_GPIO_Init+0x1be>
 80009d0:	2307      	movs	r3, #7
 80009d2:	e002      	b.n	80009da <HAL_GPIO_Init+0x1be>
 80009d4:	2301      	movs	r3, #1
 80009d6:	e000      	b.n	80009da <HAL_GPIO_Init+0x1be>
 80009d8:	2300      	movs	r3, #0
 80009da:	697a      	ldr	r2, [r7, #20]
 80009dc:	f002 0203 	and.w	r2, r2, #3
 80009e0:	0092      	lsls	r2, r2, #2
 80009e2:	4093      	lsls	r3, r2
 80009e4:	693a      	ldr	r2, [r7, #16]
 80009e6:	4313      	orrs	r3, r2
 80009e8:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 80009ea:	4938      	ldr	r1, [pc, #224]	; (8000acc <HAL_GPIO_Init+0x2b0>)
 80009ec:	697b      	ldr	r3, [r7, #20]
 80009ee:	089b      	lsrs	r3, r3, #2
 80009f0:	3302      	adds	r3, #2
 80009f2:	693a      	ldr	r2, [r7, #16]
 80009f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 80009f8:	4b37      	ldr	r3, [pc, #220]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 80009fa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80009fe:	613b      	str	r3, [r7, #16]
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8000a00:	68fb      	ldr	r3, [r7, #12]
 8000a02:	43db      	mvns	r3, r3
 8000a04:	693a      	ldr	r2, [r7, #16]
 8000a06:	4013      	ands	r3, r2
 8000a08:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8000a0a:	683b      	ldr	r3, [r7, #0]
 8000a0c:	685b      	ldr	r3, [r3, #4]
 8000a0e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000a12:	2b00      	cmp	r3, #0
 8000a14:	d003      	beq.n	8000a1e <HAL_GPIO_Init+0x202>
        {
          temp |= iocurrent;
 8000a16:	693a      	ldr	r2, [r7, #16]
 8000a18:	68fb      	ldr	r3, [r7, #12]
 8000a1a:	4313      	orrs	r3, r2
 8000a1c:	613b      	str	r3, [r7, #16]
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
#else
        EXTI->IMR1 = temp;
 8000a1e:	4a2e      	ldr	r2, [pc, #184]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000a20:	693b      	ldr	r3, [r7, #16]
 8000a22:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
#else
        temp = EXTI->EMR1;
 8000a26:	4b2c      	ldr	r3, [pc, #176]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000a28:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8000a2c:	613b      	str	r3, [r7, #16]
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8000a2e:	68fb      	ldr	r3, [r7, #12]
 8000a30:	43db      	mvns	r3, r3
 8000a32:	693a      	ldr	r2, [r7, #16]
 8000a34:	4013      	ands	r3, r2
 8000a36:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8000a38:	683b      	ldr	r3, [r7, #0]
 8000a3a:	685b      	ldr	r3, [r3, #4]
 8000a3c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000a40:	2b00      	cmp	r3, #0
 8000a42:	d003      	beq.n	8000a4c <HAL_GPIO_Init+0x230>
        {
          temp |= iocurrent;
 8000a44:	693a      	ldr	r2, [r7, #16]
 8000a46:	68fb      	ldr	r3, [r7, #12]
 8000a48:	4313      	orrs	r3, r2
 8000a4a:	613b      	str	r3, [r7, #16]
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
#else
        EXTI->EMR1 = temp;
 8000a4c:	4a22      	ldr	r2, [pc, #136]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000a4e:	693b      	ldr	r3, [r7, #16]
 8000a50:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
#endif /* CORE_CM0PLUS */

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8000a54:	4b20      	ldr	r3, [pc, #128]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000a56:	681b      	ldr	r3, [r3, #0]
 8000a58:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8000a5a:	68fb      	ldr	r3, [r7, #12]
 8000a5c:	43db      	mvns	r3, r3
 8000a5e:	693a      	ldr	r2, [r7, #16]
 8000a60:	4013      	ands	r3, r2
 8000a62:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8000a64:	683b      	ldr	r3, [r7, #0]
 8000a66:	685b      	ldr	r3, [r3, #4]
 8000a68:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000a6c:	2b00      	cmp	r3, #0
 8000a6e:	d003      	beq.n	8000a78 <HAL_GPIO_Init+0x25c>
        {
          temp |= iocurrent;
 8000a70:	693a      	ldr	r2, [r7, #16]
 8000a72:	68fb      	ldr	r3, [r7, #12]
 8000a74:	4313      	orrs	r3, r2
 8000a76:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 8000a78:	4a17      	ldr	r2, [pc, #92]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000a7a:	693b      	ldr	r3, [r7, #16]
 8000a7c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8000a7e:	4b16      	ldr	r3, [pc, #88]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000a80:	685b      	ldr	r3, [r3, #4]
 8000a82:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8000a84:	68fb      	ldr	r3, [r7, #12]
 8000a86:	43db      	mvns	r3, r3
 8000a88:	693a      	ldr	r2, [r7, #16]
 8000a8a:	4013      	ands	r3, r2
 8000a8c:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8000a8e:	683b      	ldr	r3, [r7, #0]
 8000a90:	685b      	ldr	r3, [r3, #4]
 8000a92:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000a96:	2b00      	cmp	r3, #0
 8000a98:	d003      	beq.n	8000aa2 <HAL_GPIO_Init+0x286>
        {
          temp |= iocurrent;
 8000a9a:	693a      	ldr	r2, [r7, #16]
 8000a9c:	68fb      	ldr	r3, [r7, #12]
 8000a9e:	4313      	orrs	r3, r2
 8000aa0:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8000aa2:	4a0d      	ldr	r2, [pc, #52]	; (8000ad8 <HAL_GPIO_Init+0x2bc>)
 8000aa4:	693b      	ldr	r3, [r7, #16]
 8000aa6:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
 8000aa8:	697b      	ldr	r3, [r7, #20]
 8000aaa:	3301      	adds	r3, #1
 8000aac:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8000aae:	683b      	ldr	r3, [r7, #0]
 8000ab0:	681a      	ldr	r2, [r3, #0]
 8000ab2:	697b      	ldr	r3, [r7, #20]
 8000ab4:	fa22 f303 	lsr.w	r3, r2, r3
 8000ab8:	2b00      	cmp	r3, #0
 8000aba:	f47f aeb7 	bne.w	800082c <HAL_GPIO_Init+0x10>
  }
}
 8000abe:	bf00      	nop
 8000ac0:	bf00      	nop
 8000ac2:	371c      	adds	r7, #28
 8000ac4:	46bd      	mov	sp, r7
 8000ac6:	bc80      	pop	{r7}
 8000ac8:	4770      	bx	lr
 8000aca:	bf00      	nop
 8000acc:	40010000 	.word	0x40010000
 8000ad0:	48000400 	.word	0x48000400
 8000ad4:	48000800 	.word	0x48000800
 8000ad8:	58000800 	.word	0x58000800

08000adc <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8000adc:	b480      	push	{r7}
 8000ade:	b083      	sub	sp, #12
 8000ae0:	af00      	add	r7, sp, #0
 8000ae2:	6078      	str	r0, [r7, #4]
 8000ae4:	460b      	mov	r3, r1
 8000ae6:	807b      	strh	r3, [r7, #2]
 8000ae8:	4613      	mov	r3, r2
 8000aea:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8000aec:	787b      	ldrb	r3, [r7, #1]
 8000aee:	2b00      	cmp	r3, #0
 8000af0:	d003      	beq.n	8000afa <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8000af2:	887a      	ldrh	r2, [r7, #2]
 8000af4:	687b      	ldr	r3, [r7, #4]
 8000af6:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8000af8:	e002      	b.n	8000b00 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8000afa:	887a      	ldrh	r2, [r7, #2]
 8000afc:	687b      	ldr	r3, [r7, #4]
 8000afe:	629a      	str	r2, [r3, #40]	; 0x28
}
 8000b00:	bf00      	nop
 8000b02:	370c      	adds	r7, #12
 8000b04:	46bd      	mov	sp, r7
 8000b06:	bc80      	pop	{r7}
 8000b08:	4770      	bx	lr

08000b0a <LL_RCC_SetLPTIMClockSource>:
  *         @arg @ref LL_RCC_LPTIM3_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_LPTIM3_CLKSOURCE_LSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLPTIMClockSource(uint32_t LPTIMxSource)
{
 8000b0a:	b480      	push	{r7}
 8000b0c:	b083      	sub	sp, #12
 8000b0e:	af00      	add	r7, sp, #0
 8000b10:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8000b12:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b16:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000b1a:	687b      	ldr	r3, [r7, #4]
 8000b1c:	0c1b      	lsrs	r3, r3, #16
 8000b1e:	041b      	lsls	r3, r3, #16
 8000b20:	43db      	mvns	r3, r3
 8000b22:	401a      	ands	r2, r3
 8000b24:	687b      	ldr	r3, [r7, #4]
 8000b26:	041b      	lsls	r3, r3, #16
 8000b28:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000b2c:	4313      	orrs	r3, r2
 8000b2e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8000b32:	bf00      	nop
 8000b34:	370c      	adds	r7, #12
 8000b36:	46bd      	mov	sp, r7
 8000b38:	bc80      	pop	{r7}
 8000b3a:	4770      	bx	lr

08000b3c <LL_RCC_GetLPTIMClockSource>:
  *         @arg @ref LL_RCC_LPTIM3_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_LPTIM3_CLKSOURCE_LSE

  */
__STATIC_INLINE uint32_t LL_RCC_GetLPTIMClockSource(uint32_t LPTIMx)
{
 8000b3c:	b480      	push	{r7}
 8000b3e:	b083      	sub	sp, #12
 8000b40:	af00      	add	r7, sp, #0
 8000b42:	6078      	str	r0, [r7, #4]
  return (uint32_t)((READ_BIT(RCC->CCIPR, LPTIMx) >> 16) | LPTIMx);
 8000b44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b48:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000b4c:	687b      	ldr	r3, [r7, #4]
 8000b4e:	4013      	ands	r3, r2
 8000b50:	0c1a      	lsrs	r2, r3, #16
 8000b52:	687b      	ldr	r3, [r7, #4]
 8000b54:	4313      	orrs	r3, r2
}
 8000b56:	4618      	mov	r0, r3
 8000b58:	370c      	adds	r7, #12
 8000b5a:	46bd      	mov	sp, r7
 8000b5c:	bc80      	pop	{r7}
 8000b5e:	4770      	bx	lr

08000b60 <LL_APB1_GRP1_ForceReset>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1

  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
{
 8000b60:	b480      	push	{r7}
 8000b62:	b083      	sub	sp, #12
 8000b64:	af00      	add	r7, sp, #0
 8000b66:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1RSTR1, Periphs);
 8000b68:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b6c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000b6e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000b72:	687b      	ldr	r3, [r7, #4]
 8000b74:	4313      	orrs	r3, r2
 8000b76:	638b      	str	r3, [r1, #56]	; 0x38
}
 8000b78:	bf00      	nop
 8000b7a:	370c      	adds	r7, #12
 8000b7c:	46bd      	mov	sp, r7
 8000b7e:	bc80      	pop	{r7}
 8000b80:	4770      	bx	lr

08000b82 <LL_APB1_GRP2_ForceReset>:
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM3
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP2_ForceReset(uint32_t Periphs)
{
 8000b82:	b480      	push	{r7}
 8000b84:	b083      	sub	sp, #12
 8000b86:	af00      	add	r7, sp, #0
 8000b88:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1RSTR2, Periphs);
 8000b8a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000b8e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000b90:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000b94:	687b      	ldr	r3, [r7, #4]
 8000b96:	4313      	orrs	r3, r2
 8000b98:	63cb      	str	r3, [r1, #60]	; 0x3c
}
 8000b9a:	bf00      	nop
 8000b9c:	370c      	adds	r7, #12
 8000b9e:	46bd      	mov	sp, r7
 8000ba0:	bc80      	pop	{r7}
 8000ba2:	4770      	bx	lr

08000ba4 <LL_APB1_GRP1_ReleaseReset>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1

  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
{
 8000ba4:	b480      	push	{r7}
 8000ba6:	b083      	sub	sp, #12
 8000ba8:	af00      	add	r7, sp, #0
 8000baa:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 8000bac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000bb0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8000bb2:	687b      	ldr	r3, [r7, #4]
 8000bb4:	43db      	mvns	r3, r3
 8000bb6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000bba:	4013      	ands	r3, r2
 8000bbc:	638b      	str	r3, [r1, #56]	; 0x38
}
 8000bbe:	bf00      	nop
 8000bc0:	370c      	adds	r7, #12
 8000bc2:	46bd      	mov	sp, r7
 8000bc4:	bc80      	pop	{r7}
 8000bc6:	4770      	bx	lr

08000bc8 <LL_APB1_GRP2_ReleaseReset>:
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM3
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP2_ReleaseReset(uint32_t Periphs)
{
 8000bc8:	b480      	push	{r7}
 8000bca:	b083      	sub	sp, #12
 8000bcc:	af00      	add	r7, sp, #0
 8000bce:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(RCC->APB1RSTR2, Periphs);
 8000bd0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000bd4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000bd6:	687b      	ldr	r3, [r7, #4]
 8000bd8:	43db      	mvns	r3, r3
 8000bda:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000bde:	4013      	ands	r3, r2
 8000be0:	63cb      	str	r3, [r1, #60]	; 0x3c
}
 8000be2:	bf00      	nop
 8000be4:	370c      	adds	r7, #12
 8000be6:	46bd      	mov	sp, r7
 8000be8:	bc80      	pop	{r7}
 8000bea:	4770      	bx	lr

08000bec <HAL_LPTIM_Init>:
  *         LPTIM_InitTypeDef and initialize the associated handle.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LPTIM_Init(LPTIM_HandleTypeDef *hlptim)
{
 8000bec:	b580      	push	{r7, lr}
 8000bee:	b084      	sub	sp, #16
 8000bf0:	af00      	add	r7, sp, #0
 8000bf2:	6078      	str	r0, [r7, #4]
  uint32_t tmpcfgr;

  /* Check the LPTIM handle allocation */
  if (hlptim == NULL)
 8000bf4:	687b      	ldr	r3, [r7, #4]
 8000bf6:	2b00      	cmp	r3, #0
 8000bf8:	d101      	bne.n	8000bfe <HAL_LPTIM_Init+0x12>
  {
    return HAL_ERROR;
 8000bfa:	2301      	movs	r3, #1
 8000bfc:	e0b6      	b.n	8000d6c <HAL_LPTIM_Init+0x180>
  /* Check the parameters */
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));

  assert_param(IS_LPTIM_CLOCK_SOURCE(hlptim->Init.Clock.Source));
  assert_param(IS_LPTIM_CLOCK_PRESCALER(hlptim->Init.Clock.Prescaler));
  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)
 8000bfe:	687b      	ldr	r3, [r7, #4]
 8000c00:	685b      	ldr	r3, [r3, #4]
 8000c02:	2b01      	cmp	r3, #1
  assert_param(IS_LPTIM_OUTPUT_POLARITY(hlptim->Init.OutputPolarity));
  assert_param(IS_LPTIM_UPDATE_MODE(hlptim->Init.UpdateMode));
  assert_param(IS_LPTIM_COUNTER_SOURCE(hlptim->Init.CounterSource));
  assert_param(IS_LPTIM_REPETITION(hlptim->Init.RepetitionCounter));

  if (hlptim->State == HAL_LPTIM_STATE_RESET)
 8000c04:	687b      	ldr	r3, [r7, #4]
 8000c06:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8000c0a:	b2db      	uxtb	r3, r3
 8000c0c:	2b00      	cmp	r3, #0
 8000c0e:	d106      	bne.n	8000c1e <HAL_LPTIM_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hlptim->Lock = HAL_UNLOCKED;
 8000c10:	687b      	ldr	r3, [r7, #4]
 8000c12:	2200      	movs	r2, #0
 8000c14:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hlptim->MspInitCallback(hlptim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_LPTIM_MspInit(hlptim);
 8000c18:	6878      	ldr	r0, [r7, #4]
 8000c1a:	f7ff fbc3 	bl	80003a4 <HAL_LPTIM_MspInit>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
  }

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 8000c1e:	687b      	ldr	r3, [r7, #4]
 8000c20:	2202      	movs	r2, #2
 8000c22:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  /* Enable the Peripheral */
  __HAL_LPTIM_ENABLE(hlptim);
 8000c26:	687b      	ldr	r3, [r7, #4]
 8000c28:	681b      	ldr	r3, [r3, #0]
 8000c2a:	691a      	ldr	r2, [r3, #16]
 8000c2c:	687b      	ldr	r3, [r7, #4]
 8000c2e:	681b      	ldr	r3, [r3, #0]
 8000c30:	f042 0201 	orr.w	r2, r2, #1
 8000c34:	611a      	str	r2, [r3, #16]

  /* Clear flag */
  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_REPOK);
 8000c36:	687b      	ldr	r3, [r7, #4]
 8000c38:	681b      	ldr	r3, [r3, #0]
 8000c3a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000c3e:	605a      	str	r2, [r3, #4]

  /* Set the repetition counter */
  __HAL_LPTIM_REPETITIONCOUNTER_SET(hlptim, hlptim->Init.RepetitionCounter);
 8000c40:	687b      	ldr	r3, [r7, #4]
 8000c42:	681b      	ldr	r3, [r3, #0]
 8000c44:	687a      	ldr	r2, [r7, #4]
 8000c46:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8000c48:	629a      	str	r2, [r3, #40]	; 0x28

  /* Wait for the completion of the write operation to the LPTIM_RCR register */
  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_REPOK) == HAL_TIMEOUT)
 8000c4a:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000c4e:	6878      	ldr	r0, [r7, #4]
 8000c50:	f000 fa5c 	bl	800110c <LPTIM_WaitForFlag>
 8000c54:	4603      	mov	r3, r0
 8000c56:	2b03      	cmp	r3, #3
 8000c58:	d101      	bne.n	8000c5e <HAL_LPTIM_Init+0x72>
  {
    return HAL_TIMEOUT;
 8000c5a:	2303      	movs	r3, #3
 8000c5c:	e086      	b.n	8000d6c <HAL_LPTIM_Init+0x180>
  }

  /* Disable the Peripheral */
  __HAL_LPTIM_DISABLE(hlptim);
 8000c5e:	6878      	ldr	r0, [r7, #4]
 8000c60:	f000 fa84 	bl	800116c <LPTIM_Disable>

  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)
 8000c64:	6878      	ldr	r0, [r7, #4]
 8000c66:	f000 fa44 	bl	80010f2 <HAL_LPTIM_GetState>
 8000c6a:	4603      	mov	r3, r0
 8000c6c:	2b03      	cmp	r3, #3
 8000c6e:	d101      	bne.n	8000c74 <HAL_LPTIM_Init+0x88>
  {
    return HAL_TIMEOUT;
 8000c70:	2303      	movs	r3, #3
 8000c72:	e07b      	b.n	8000d6c <HAL_LPTIM_Init+0x180>
  }


  /* Get the LPTIMx CFGR value */
  tmpcfgr = hlptim->Instance->CFGR;
 8000c74:	687b      	ldr	r3, [r7, #4]
 8000c76:	681b      	ldr	r3, [r3, #0]
 8000c78:	68db      	ldr	r3, [r3, #12]
 8000c7a:	60fb      	str	r3, [r7, #12]

  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)
 8000c7c:	687b      	ldr	r3, [r7, #4]
 8000c7e:	685b      	ldr	r3, [r3, #4]
 8000c80:	2b01      	cmp	r3, #1
 8000c82:	d004      	beq.n	8000c8e <HAL_LPTIM_Init+0xa2>
      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))
 8000c84:	687b      	ldr	r3, [r7, #4]
 8000c86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000c88:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8000c8c:	d103      	bne.n	8000c96 <HAL_LPTIM_Init+0xaa>
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKPOL | LPTIM_CFGR_CKFLT));
 8000c8e:	68fb      	ldr	r3, [r7, #12]
 8000c90:	f023 031e 	bic.w	r3, r3, #30
 8000c94:	60fb      	str	r3, [r7, #12]
  }
  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)
 8000c96:	687b      	ldr	r3, [r7, #4]
 8000c98:	695b      	ldr	r3, [r3, #20]
 8000c9a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000c9e:	4293      	cmp	r3, r2
 8000ca0:	d005      	beq.n	8000cae <HAL_LPTIM_Init+0xc2>
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_TRGFLT | LPTIM_CFGR_TRIGSEL));
 8000ca2:	68fb      	ldr	r3, [r7, #12]
 8000ca4:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000ca8:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8000cac:	60fb      	str	r3, [r7, #12]
  }

  /* Clear CKSEL, PRESC, TRIGEN, TRGFLT, WAVPOL, PRELOAD & COUNTMODE bits */
  tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKSEL | LPTIM_CFGR_TRIGEN | LPTIM_CFGR_PRELOAD |
 8000cae:	68fa      	ldr	r2, [r7, #12]
 8000cb0:	4b30      	ldr	r3, [pc, #192]	; (8000d74 <HAL_LPTIM_Init+0x188>)
 8000cb2:	4013      	ands	r3, r2
 8000cb4:	60fb      	str	r3, [r7, #12]
                          LPTIM_CFGR_WAVPOL | LPTIM_CFGR_PRESC | LPTIM_CFGR_COUNTMODE));

  /* Set initialization parameters */
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 8000cb6:	687b      	ldr	r3, [r7, #4]
 8000cb8:	685a      	ldr	r2, [r3, #4]
              hlptim->Init.Clock.Prescaler |
 8000cba:	687b      	ldr	r3, [r7, #4]
 8000cbc:	689b      	ldr	r3, [r3, #8]
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 8000cbe:	431a      	orrs	r2, r3
              hlptim->Init.OutputPolarity  |
 8000cc0:	687b      	ldr	r3, [r7, #4]
 8000cc2:	6a1b      	ldr	r3, [r3, #32]
              hlptim->Init.Clock.Prescaler |
 8000cc4:	431a      	orrs	r2, r3
              hlptim->Init.UpdateMode      |
 8000cc6:	687b      	ldr	r3, [r7, #4]
 8000cc8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
              hlptim->Init.OutputPolarity  |
 8000cca:	431a      	orrs	r2, r3
              hlptim->Init.CounterSource);
 8000ccc:	687b      	ldr	r3, [r7, #4]
 8000cce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
              hlptim->Init.UpdateMode      |
 8000cd0:	4313      	orrs	r3, r2
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 8000cd2:	68fa      	ldr	r2, [r7, #12]
 8000cd4:	4313      	orrs	r3, r2
 8000cd6:	60fb      	str	r3, [r7, #12]

  /* Glitch filters for internal triggers and  external inputs are configured
   * only if an internal clock source is provided to the LPTIM
   */
  if (hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC)
 8000cd8:	687b      	ldr	r3, [r7, #4]
 8000cda:	685b      	ldr	r3, [r3, #4]
 8000cdc:	2b00      	cmp	r3, #0
 8000cde:	d107      	bne.n	8000cf0 <HAL_LPTIM_Init+0x104>
  {
    tmpcfgr |= (hlptim->Init.Trigger.SampleTime |
 8000ce0:	687b      	ldr	r3, [r7, #4]
 8000ce2:	69da      	ldr	r2, [r3, #28]
                hlptim->Init.UltraLowPowerClock.SampleTime);
 8000ce4:	687b      	ldr	r3, [r7, #4]
 8000ce6:	691b      	ldr	r3, [r3, #16]
    tmpcfgr |= (hlptim->Init.Trigger.SampleTime |
 8000ce8:	4313      	orrs	r3, r2
 8000cea:	68fa      	ldr	r2, [r7, #12]
 8000cec:	4313      	orrs	r3, r2
 8000cee:	60fb      	str	r3, [r7, #12]
  }

  /* Configure LPTIM external clock polarity and digital filter */
  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)
 8000cf0:	687b      	ldr	r3, [r7, #4]
 8000cf2:	685b      	ldr	r3, [r3, #4]
 8000cf4:	2b01      	cmp	r3, #1
 8000cf6:	d004      	beq.n	8000d02 <HAL_LPTIM_Init+0x116>
      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))
 8000cf8:	687b      	ldr	r3, [r7, #4]
 8000cfa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000cfc:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8000d00:	d107      	bne.n	8000d12 <HAL_LPTIM_Init+0x126>
  {
    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |
 8000d02:	687b      	ldr	r3, [r7, #4]
 8000d04:	68da      	ldr	r2, [r3, #12]
                hlptim->Init.UltraLowPowerClock.SampleTime);
 8000d06:	687b      	ldr	r3, [r7, #4]
 8000d08:	691b      	ldr	r3, [r3, #16]
    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |
 8000d0a:	4313      	orrs	r3, r2
 8000d0c:	68fa      	ldr	r2, [r7, #12]
 8000d0e:	4313      	orrs	r3, r2
 8000d10:	60fb      	str	r3, [r7, #12]
  }

  /* Configure LPTIM external trigger */
  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)
 8000d12:	687b      	ldr	r3, [r7, #4]
 8000d14:	695b      	ldr	r3, [r3, #20]
 8000d16:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000d1a:	4293      	cmp	r3, r2
 8000d1c:	d00a      	beq.n	8000d34 <HAL_LPTIM_Init+0x148>
  {
    /* Enable External trigger and set the trigger source */
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8000d1e:	687b      	ldr	r3, [r7, #4]
 8000d20:	695a      	ldr	r2, [r3, #20]
                hlptim->Init.Trigger.ActiveEdge |
 8000d22:	687b      	ldr	r3, [r7, #4]
 8000d24:	699b      	ldr	r3, [r3, #24]
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8000d26:	431a      	orrs	r2, r3
                hlptim->Init.Trigger.SampleTime);
 8000d28:	687b      	ldr	r3, [r7, #4]
 8000d2a:	69db      	ldr	r3, [r3, #28]
                hlptim->Init.Trigger.ActiveEdge |
 8000d2c:	4313      	orrs	r3, r2
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8000d2e:	68fa      	ldr	r2, [r7, #12]
 8000d30:	4313      	orrs	r3, r2
 8000d32:	60fb      	str	r3, [r7, #12]
  }

  /* Write to LPTIMx CFGR */
  hlptim->Instance->CFGR = tmpcfgr;
 8000d34:	687b      	ldr	r3, [r7, #4]
 8000d36:	681b      	ldr	r3, [r3, #0]
 8000d38:	68fa      	ldr	r2, [r7, #12]
 8000d3a:	60da      	str	r2, [r3, #12]

  /* Configure LPTIM input sources */
  if (hlptim->Instance == LPTIM1)
 8000d3c:	687b      	ldr	r3, [r7, #4]
 8000d3e:	681b      	ldr	r3, [r3, #0]
 8000d40:	4a0d      	ldr	r2, [pc, #52]	; (8000d78 <HAL_LPTIM_Init+0x18c>)
 8000d42:	4293      	cmp	r3, r2
 8000d44:	d108      	bne.n	8000d58 <HAL_LPTIM_Init+0x16c>
    /* Check LPTIM Input1 and Input2 sources */
    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance, hlptim->Init.Input1Source));
    assert_param(IS_LPTIM_INPUT2_SOURCE(hlptim->Instance, hlptim->Init.Input2Source));

    /* Configure LPTIM Input1 and Input2 sources */
    hlptim->Instance->OR = (hlptim->Init.Input1Source | hlptim->Init.Input2Source);
 8000d46:	687b      	ldr	r3, [r7, #4]
 8000d48:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8000d4a:	687b      	ldr	r3, [r7, #4]
 8000d4c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000d4e:	687b      	ldr	r3, [r7, #4]
 8000d50:	681b      	ldr	r3, [r3, #0]
 8000d52:	430a      	orrs	r2, r1
 8000d54:	621a      	str	r2, [r3, #32]
 8000d56:	e004      	b.n	8000d62 <HAL_LPTIM_Init+0x176>
  {
    /* Check LPTIM2 and LPTIM3 Input1 source */
    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance, hlptim->Init.Input1Source));

    /* Configure LPTIM2 and LPTIM3 Input1 source */
    hlptim->Instance->OR = hlptim->Init.Input1Source;
 8000d58:	687b      	ldr	r3, [r7, #4]
 8000d5a:	681b      	ldr	r3, [r3, #0]
 8000d5c:	687a      	ldr	r2, [r7, #4]
 8000d5e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8000d60:	621a      	str	r2, [r3, #32]
  }

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_READY;
 8000d62:	687b      	ldr	r3, [r7, #4]
 8000d64:	2201      	movs	r2, #1
 8000d66:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  /* Return function status */
  return HAL_OK;
 8000d6a:	2300      	movs	r3, #0
}
 8000d6c:	4618      	mov	r0, r3
 8000d6e:	3710      	adds	r7, #16
 8000d70:	46bd      	mov	sp, r7
 8000d72:	bd80      	pop	{r7, pc}
 8000d74:	ff19f1fe 	.word	0xff19f1fe
 8000d78:	40007c00 	.word	0x40007c00

08000d7c <HAL_LPTIM_Counter_Start_IT>:
  * @param  Period Specifies the Autoreload value.
  *         This parameter must be a value between 0x0000 and 0xFFFF.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LPTIM_Counter_Start_IT(LPTIM_HandleTypeDef *hlptim, uint32_t Period)
{
 8000d7c:	b580      	push	{r7, lr}
 8000d7e:	b082      	sub	sp, #8
 8000d80:	af00      	add	r7, sp, #0
 8000d82:	6078      	str	r0, [r7, #4]
 8000d84:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));
  assert_param(IS_LPTIM_PERIOD(Period));

  /* Set the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 8000d86:	687b      	ldr	r3, [r7, #4]
 8000d88:	2202      	movs	r2, #2
 8000d8a:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  /* Enable EXTI Line interrupt on the LPTIM Wake-up Timer */
  __HAL_LPTIM_WAKEUPTIMER_EXTI_ENABLE_IT(hlptim->Instance);
 8000d8e:	687b      	ldr	r3, [r7, #4]
 8000d90:	681b      	ldr	r3, [r3, #0]
 8000d92:	4a48      	ldr	r2, [pc, #288]	; (8000eb4 <HAL_LPTIM_Counter_Start_IT+0x138>)
 8000d94:	4293      	cmp	r3, r2
 8000d96:	d108      	bne.n	8000daa <HAL_LPTIM_Counter_Start_IT+0x2e>
 8000d98:	4b47      	ldr	r3, [pc, #284]	; (8000eb8 <HAL_LPTIM_Counter_Start_IT+0x13c>)
 8000d9a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000d9e:	4a46      	ldr	r2, [pc, #280]	; (8000eb8 <HAL_LPTIM_Counter_Start_IT+0x13c>)
 8000da0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000da4:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 8000da8:	e015      	b.n	8000dd6 <HAL_LPTIM_Counter_Start_IT+0x5a>
 8000daa:	687b      	ldr	r3, [r7, #4]
 8000dac:	681b      	ldr	r3, [r3, #0]
 8000dae:	4a43      	ldr	r2, [pc, #268]	; (8000ebc <HAL_LPTIM_Counter_Start_IT+0x140>)
 8000db0:	4293      	cmp	r3, r2
 8000db2:	d108      	bne.n	8000dc6 <HAL_LPTIM_Counter_Start_IT+0x4a>
 8000db4:	4b40      	ldr	r3, [pc, #256]	; (8000eb8 <HAL_LPTIM_Counter_Start_IT+0x13c>)
 8000db6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000dba:	4a3f      	ldr	r2, [pc, #252]	; (8000eb8 <HAL_LPTIM_Counter_Start_IT+0x13c>)
 8000dbc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000dc0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
 8000dc4:	e007      	b.n	8000dd6 <HAL_LPTIM_Counter_Start_IT+0x5a>
 8000dc6:	4b3c      	ldr	r3, [pc, #240]	; (8000eb8 <HAL_LPTIM_Counter_Start_IT+0x13c>)
 8000dc8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000dcc:	4a3a      	ldr	r2, [pc, #232]	; (8000eb8 <HAL_LPTIM_Counter_Start_IT+0x13c>)
 8000dce:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000dd2:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

  /* If clock source is not ULPTIM clock and counter source is external, then it must not be prescaled */
  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM) &&
 8000dd6:	687b      	ldr	r3, [r7, #4]
 8000dd8:	685b      	ldr	r3, [r3, #4]
 8000dda:	2b01      	cmp	r3, #1
 8000ddc:	d00c      	beq.n	8000df8 <HAL_LPTIM_Counter_Start_IT+0x7c>
      (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))
 8000dde:	687b      	ldr	r3, [r7, #4]
 8000de0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if ((hlptim->Init.Clock.Source != LPTIM_CLOCKSOURCE_ULPTIM) &&
 8000de2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8000de6:	d107      	bne.n	8000df8 <HAL_LPTIM_Counter_Start_IT+0x7c>
  {
    /* Check if clock is prescaled */
    assert_param(IS_LPTIM_CLOCK_PRESCALERDIV1(hlptim->Init.Clock.Prescaler));
    /* Set clock prescaler to 0 */
    hlptim->Instance->CFGR &= ~LPTIM_CFGR_PRESC;
 8000de8:	687b      	ldr	r3, [r7, #4]
 8000dea:	681b      	ldr	r3, [r3, #0]
 8000dec:	68da      	ldr	r2, [r3, #12]
 8000dee:	687b      	ldr	r3, [r7, #4]
 8000df0:	681b      	ldr	r3, [r3, #0]
 8000df2:	f422 6260 	bic.w	r2, r2, #3584	; 0xe00
 8000df6:	60da      	str	r2, [r3, #12]
  }

  /* Enable the Peripheral */
  __HAL_LPTIM_ENABLE(hlptim);
 8000df8:	687b      	ldr	r3, [r7, #4]
 8000dfa:	681b      	ldr	r3, [r3, #0]
 8000dfc:	691a      	ldr	r2, [r3, #16]
 8000dfe:	687b      	ldr	r3, [r7, #4]
 8000e00:	681b      	ldr	r3, [r3, #0]
 8000e02:	f042 0201 	orr.w	r2, r2, #1
 8000e06:	611a      	str	r2, [r3, #16]

  /* Clear flag */
  __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);
 8000e08:	687b      	ldr	r3, [r7, #4]
 8000e0a:	681b      	ldr	r3, [r3, #0]
 8000e0c:	2210      	movs	r2, #16
 8000e0e:	605a      	str	r2, [r3, #4]

  /* Load the period value in the autoreload register */
  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);
 8000e10:	687b      	ldr	r3, [r7, #4]
 8000e12:	681b      	ldr	r3, [r3, #0]
 8000e14:	683a      	ldr	r2, [r7, #0]
 8000e16:	619a      	str	r2, [r3, #24]

  /* Wait for the completion of the write operation to the LPTIM_ARR register */
  if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)
 8000e18:	2110      	movs	r1, #16
 8000e1a:	6878      	ldr	r0, [r7, #4]
 8000e1c:	f000 f976 	bl	800110c <LPTIM_WaitForFlag>
 8000e20:	4603      	mov	r3, r0
 8000e22:	2b03      	cmp	r3, #3
 8000e24:	d101      	bne.n	8000e2a <HAL_LPTIM_Counter_Start_IT+0xae>
  {
    return HAL_TIMEOUT;
 8000e26:	2303      	movs	r3, #3
 8000e28:	e03f      	b.n	8000eaa <HAL_LPTIM_Counter_Start_IT+0x12e>
  }

  /* Disable the Peripheral */
  __HAL_LPTIM_DISABLE(hlptim);
 8000e2a:	6878      	ldr	r0, [r7, #4]
 8000e2c:	f000 f99e 	bl	800116c <LPTIM_Disable>

  if (HAL_LPTIM_GetState(hlptim) == HAL_LPTIM_STATE_TIMEOUT)
 8000e30:	6878      	ldr	r0, [r7, #4]
 8000e32:	f000 f95e 	bl	80010f2 <HAL_LPTIM_GetState>
 8000e36:	4603      	mov	r3, r0
 8000e38:	2b03      	cmp	r3, #3
 8000e3a:	d101      	bne.n	8000e40 <HAL_LPTIM_Counter_Start_IT+0xc4>
  {
    return HAL_TIMEOUT;
 8000e3c:	2303      	movs	r3, #3
 8000e3e:	e034      	b.n	8000eaa <HAL_LPTIM_Counter_Start_IT+0x12e>
  }

  /* Enable Autoreload write complete interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARROK);
 8000e40:	687b      	ldr	r3, [r7, #4]
 8000e42:	681b      	ldr	r3, [r3, #0]
 8000e44:	689a      	ldr	r2, [r3, #8]
 8000e46:	687b      	ldr	r3, [r7, #4]
 8000e48:	681b      	ldr	r3, [r3, #0]
 8000e4a:	f042 0210 	orr.w	r2, r2, #16
 8000e4e:	609a      	str	r2, [r3, #8]

  /* Enable Autoreload match interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_ARRM);
 8000e50:	687b      	ldr	r3, [r7, #4]
 8000e52:	681b      	ldr	r3, [r3, #0]
 8000e54:	689a      	ldr	r2, [r3, #8]
 8000e56:	687b      	ldr	r3, [r7, #4]
 8000e58:	681b      	ldr	r3, [r3, #0]
 8000e5a:	f042 0202 	orr.w	r2, r2, #2
 8000e5e:	609a      	str	r2, [r3, #8]

  /* Enable Rep Update Ok interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_REPOK);
 8000e60:	687b      	ldr	r3, [r7, #4]
 8000e62:	681b      	ldr	r3, [r3, #0]
 8000e64:	689a      	ldr	r2, [r3, #8]
 8000e66:	687b      	ldr	r3, [r7, #4]
 8000e68:	681b      	ldr	r3, [r3, #0]
 8000e6a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000e6e:	609a      	str	r2, [r3, #8]

  /* Enable Update Event interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_UPDATE);
 8000e70:	687b      	ldr	r3, [r7, #4]
 8000e72:	681b      	ldr	r3, [r3, #0]
 8000e74:	689a      	ldr	r2, [r3, #8]
 8000e76:	687b      	ldr	r3, [r7, #4]
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000e7e:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_LPTIM_ENABLE(hlptim);
 8000e80:	687b      	ldr	r3, [r7, #4]
 8000e82:	681b      	ldr	r3, [r3, #0]
 8000e84:	691a      	ldr	r2, [r3, #16]
 8000e86:	687b      	ldr	r3, [r7, #4]
 8000e88:	681b      	ldr	r3, [r3, #0]
 8000e8a:	f042 0201 	orr.w	r2, r2, #1
 8000e8e:	611a      	str	r2, [r3, #16]

  /* Start timer in continuous mode */
  __HAL_LPTIM_START_CONTINUOUS(hlptim);
 8000e90:	687b      	ldr	r3, [r7, #4]
 8000e92:	681b      	ldr	r3, [r3, #0]
 8000e94:	691a      	ldr	r2, [r3, #16]
 8000e96:	687b      	ldr	r3, [r7, #4]
 8000e98:	681b      	ldr	r3, [r3, #0]
 8000e9a:	f042 0204 	orr.w	r2, r2, #4
 8000e9e:	611a      	str	r2, [r3, #16]

  /* Change the TIM state*/
  hlptim->State = HAL_LPTIM_STATE_READY;
 8000ea0:	687b      	ldr	r3, [r7, #4]
 8000ea2:	2201      	movs	r2, #1
 8000ea4:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  /* Return function status */
  return HAL_OK;
 8000ea8:	2300      	movs	r3, #0
}
 8000eaa:	4618      	mov	r0, r3
 8000eac:	3708      	adds	r7, #8
 8000eae:	46bd      	mov	sp, r7
 8000eb0:	bd80      	pop	{r7, pc}
 8000eb2:	bf00      	nop
 8000eb4:	40007c00 	.word	0x40007c00
 8000eb8:	58000800 	.word	0x58000800
 8000ebc:	40009400 	.word	0x40009400

08000ec0 <HAL_LPTIM_IRQHandler>:
  * @brief  Handle LPTIM interrupt request.
  * @param  hlptim LPTIM handle
  * @retval None
  */
void HAL_LPTIM_IRQHandler(LPTIM_HandleTypeDef *hlptim)
{
 8000ec0:	b580      	push	{r7, lr}
 8000ec2:	b082      	sub	sp, #8
 8000ec4:	af00      	add	r7, sp, #0
 8000ec6:	6078      	str	r0, [r7, #4]
  /* Compare match interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPM) != RESET)
 8000ec8:	687b      	ldr	r3, [r7, #4]
 8000eca:	681b      	ldr	r3, [r3, #0]
 8000ecc:	681b      	ldr	r3, [r3, #0]
 8000ece:	f003 0301 	and.w	r3, r3, #1
 8000ed2:	2b01      	cmp	r3, #1
 8000ed4:	d10d      	bne.n	8000ef2 <HAL_LPTIM_IRQHandler+0x32>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPM) != RESET)
 8000ed6:	687b      	ldr	r3, [r7, #4]
 8000ed8:	681b      	ldr	r3, [r3, #0]
 8000eda:	689b      	ldr	r3, [r3, #8]
 8000edc:	f003 0301 	and.w	r3, r3, #1
 8000ee0:	2b01      	cmp	r3, #1
 8000ee2:	d106      	bne.n	8000ef2 <HAL_LPTIM_IRQHandler+0x32>
    {
      /* Clear Compare match flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPM);
 8000ee4:	687b      	ldr	r3, [r7, #4]
 8000ee6:	681b      	ldr	r3, [r3, #0]
 8000ee8:	2201      	movs	r2, #1
 8000eea:	605a      	str	r2, [r3, #4]

      /* Compare match Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->CompareMatchCallback(hlptim);
#else
      HAL_LPTIM_CompareMatchCallback(hlptim);
 8000eec:	6878      	ldr	r0, [r7, #4]
 8000eee:	f000 f8af 	bl	8001050 <HAL_LPTIM_CompareMatchCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Autoreload match interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARRM) != RESET)
 8000ef2:	687b      	ldr	r3, [r7, #4]
 8000ef4:	681b      	ldr	r3, [r3, #0]
 8000ef6:	681b      	ldr	r3, [r3, #0]
 8000ef8:	f003 0302 	and.w	r3, r3, #2
 8000efc:	2b02      	cmp	r3, #2
 8000efe:	d10d      	bne.n	8000f1c <HAL_LPTIM_IRQHandler+0x5c>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARRM) != RESET)
 8000f00:	687b      	ldr	r3, [r7, #4]
 8000f02:	681b      	ldr	r3, [r3, #0]
 8000f04:	689b      	ldr	r3, [r3, #8]
 8000f06:	f003 0302 	and.w	r3, r3, #2
 8000f0a:	2b02      	cmp	r3, #2
 8000f0c:	d106      	bne.n	8000f1c <HAL_LPTIM_IRQHandler+0x5c>
    {
      /* Clear Autoreload match flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARRM);
 8000f0e:	687b      	ldr	r3, [r7, #4]
 8000f10:	681b      	ldr	r3, [r3, #0]
 8000f12:	2202      	movs	r2, #2
 8000f14:	605a      	str	r2, [r3, #4]

      /* Autoreload match Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->AutoReloadMatchCallback(hlptim);
#else
      HAL_LPTIM_AutoReloadMatchCallback(hlptim);
 8000f16:	6878      	ldr	r0, [r7, #4]
 8000f18:	f000 f8a3 	bl	8001062 <HAL_LPTIM_AutoReloadMatchCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Trigger detected interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_EXTTRIG) != RESET)
 8000f1c:	687b      	ldr	r3, [r7, #4]
 8000f1e:	681b      	ldr	r3, [r3, #0]
 8000f20:	681b      	ldr	r3, [r3, #0]
 8000f22:	f003 0304 	and.w	r3, r3, #4
 8000f26:	2b04      	cmp	r3, #4
 8000f28:	d10d      	bne.n	8000f46 <HAL_LPTIM_IRQHandler+0x86>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_EXTTRIG) != RESET)
 8000f2a:	687b      	ldr	r3, [r7, #4]
 8000f2c:	681b      	ldr	r3, [r3, #0]
 8000f2e:	689b      	ldr	r3, [r3, #8]
 8000f30:	f003 0304 	and.w	r3, r3, #4
 8000f34:	2b04      	cmp	r3, #4
 8000f36:	d106      	bne.n	8000f46 <HAL_LPTIM_IRQHandler+0x86>
    {
      /* Clear Trigger detected flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_EXTTRIG);
 8000f38:	687b      	ldr	r3, [r7, #4]
 8000f3a:	681b      	ldr	r3, [r3, #0]
 8000f3c:	2204      	movs	r2, #4
 8000f3e:	605a      	str	r2, [r3, #4]

      /* Trigger detected callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->TriggerCallback(hlptim);
#else
      HAL_LPTIM_TriggerCallback(hlptim);
 8000f40:	6878      	ldr	r0, [r7, #4]
 8000f42:	f000 f897 	bl	8001074 <HAL_LPTIM_TriggerCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Compare write interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPOK) != RESET)
 8000f46:	687b      	ldr	r3, [r7, #4]
 8000f48:	681b      	ldr	r3, [r3, #0]
 8000f4a:	681b      	ldr	r3, [r3, #0]
 8000f4c:	f003 0308 	and.w	r3, r3, #8
 8000f50:	2b08      	cmp	r3, #8
 8000f52:	d10d      	bne.n	8000f70 <HAL_LPTIM_IRQHandler+0xb0>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPOK) != RESET)
 8000f54:	687b      	ldr	r3, [r7, #4]
 8000f56:	681b      	ldr	r3, [r3, #0]
 8000f58:	689b      	ldr	r3, [r3, #8]
 8000f5a:	f003 0308 	and.w	r3, r3, #8
 8000f5e:	2b08      	cmp	r3, #8
 8000f60:	d106      	bne.n	8000f70 <HAL_LPTIM_IRQHandler+0xb0>
    {
      /* Clear Compare write flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);
 8000f62:	687b      	ldr	r3, [r7, #4]
 8000f64:	681b      	ldr	r3, [r3, #0]
 8000f66:	2208      	movs	r2, #8
 8000f68:	605a      	str	r2, [r3, #4]

      /* Compare write Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->CompareWriteCallback(hlptim);
#else
      HAL_LPTIM_CompareWriteCallback(hlptim);
 8000f6a:	6878      	ldr	r0, [r7, #4]
 8000f6c:	f000 f88b 	bl	8001086 <HAL_LPTIM_CompareWriteCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Autoreload write interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARROK) != RESET)
 8000f70:	687b      	ldr	r3, [r7, #4]
 8000f72:	681b      	ldr	r3, [r3, #0]
 8000f74:	681b      	ldr	r3, [r3, #0]
 8000f76:	f003 0310 	and.w	r3, r3, #16
 8000f7a:	2b10      	cmp	r3, #16
 8000f7c:	d10d      	bne.n	8000f9a <HAL_LPTIM_IRQHandler+0xda>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARROK) != RESET)
 8000f7e:	687b      	ldr	r3, [r7, #4]
 8000f80:	681b      	ldr	r3, [r3, #0]
 8000f82:	689b      	ldr	r3, [r3, #8]
 8000f84:	f003 0310 	and.w	r3, r3, #16
 8000f88:	2b10      	cmp	r3, #16
 8000f8a:	d106      	bne.n	8000f9a <HAL_LPTIM_IRQHandler+0xda>
    {
      /* Clear Autoreload write flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);
 8000f8c:	687b      	ldr	r3, [r7, #4]
 8000f8e:	681b      	ldr	r3, [r3, #0]
 8000f90:	2210      	movs	r2, #16
 8000f92:	605a      	str	r2, [r3, #4]

      /* Autoreload write Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->AutoReloadWriteCallback(hlptim);
#else
      HAL_LPTIM_AutoReloadWriteCallback(hlptim);
 8000f94:	6878      	ldr	r0, [r7, #4]
 8000f96:	f000 f87f 	bl	8001098 <HAL_LPTIM_AutoReloadWriteCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Direction counter changed from Down to Up interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UP) != RESET)
 8000f9a:	687b      	ldr	r3, [r7, #4]
 8000f9c:	681b      	ldr	r3, [r3, #0]
 8000f9e:	681b      	ldr	r3, [r3, #0]
 8000fa0:	f003 0320 	and.w	r3, r3, #32
 8000fa4:	2b20      	cmp	r3, #32
 8000fa6:	d10d      	bne.n	8000fc4 <HAL_LPTIM_IRQHandler+0x104>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UP) != RESET)
 8000fa8:	687b      	ldr	r3, [r7, #4]
 8000faa:	681b      	ldr	r3, [r3, #0]
 8000fac:	689b      	ldr	r3, [r3, #8]
 8000fae:	f003 0320 	and.w	r3, r3, #32
 8000fb2:	2b20      	cmp	r3, #32
 8000fb4:	d106      	bne.n	8000fc4 <HAL_LPTIM_IRQHandler+0x104>
    {
      /* Clear Direction counter changed from Down to Up flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UP);
 8000fb6:	687b      	ldr	r3, [r7, #4]
 8000fb8:	681b      	ldr	r3, [r3, #0]
 8000fba:	2220      	movs	r2, #32
 8000fbc:	605a      	str	r2, [r3, #4]

      /* Direction counter changed from Down to Up Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->DirectionUpCallback(hlptim);
#else
      HAL_LPTIM_DirectionUpCallback(hlptim);
 8000fbe:	6878      	ldr	r0, [r7, #4]
 8000fc0:	f000 f873 	bl	80010aa <HAL_LPTIM_DirectionUpCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Direction counter changed from Up to Down interrupt */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_DOWN) != RESET)
 8000fc4:	687b      	ldr	r3, [r7, #4]
 8000fc6:	681b      	ldr	r3, [r3, #0]
 8000fc8:	681b      	ldr	r3, [r3, #0]
 8000fca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000fce:	2b40      	cmp	r3, #64	; 0x40
 8000fd0:	d10d      	bne.n	8000fee <HAL_LPTIM_IRQHandler+0x12e>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_DOWN) != RESET)
 8000fd2:	687b      	ldr	r3, [r7, #4]
 8000fd4:	681b      	ldr	r3, [r3, #0]
 8000fd6:	689b      	ldr	r3, [r3, #8]
 8000fd8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000fdc:	2b40      	cmp	r3, #64	; 0x40
 8000fde:	d106      	bne.n	8000fee <HAL_LPTIM_IRQHandler+0x12e>
    {
      /* Clear Direction counter changed from Up to Down flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_DOWN);
 8000fe0:	687b      	ldr	r3, [r7, #4]
 8000fe2:	681b      	ldr	r3, [r3, #0]
 8000fe4:	2240      	movs	r2, #64	; 0x40
 8000fe6:	605a      	str	r2, [r3, #4]

      /* Direction counter changed from Up to Down Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->DirectionDownCallback(hlptim);
#else
      HAL_LPTIM_DirectionDownCallback(hlptim);
 8000fe8:	6878      	ldr	r0, [r7, #4]
 8000fea:	f000 f867 	bl	80010bc <HAL_LPTIM_DirectionDownCallback>
    }
  }

  /* Repetition counter underflowed (or contains zero) and the LPTIM counter
     overflowed */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UPDATE) != RESET)
 8000fee:	687b      	ldr	r3, [r7, #4]
 8000ff0:	681b      	ldr	r3, [r3, #0]
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000ff8:	2b80      	cmp	r3, #128	; 0x80
 8000ffa:	d10d      	bne.n	8001018 <HAL_LPTIM_IRQHandler+0x158>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UPDATE) != RESET)
 8000ffc:	687b      	ldr	r3, [r7, #4]
 8000ffe:	681b      	ldr	r3, [r3, #0]
 8001000:	689b      	ldr	r3, [r3, #8]
 8001002:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001006:	2b80      	cmp	r3, #128	; 0x80
 8001008:	d106      	bne.n	8001018 <HAL_LPTIM_IRQHandler+0x158>
    {
      /* Clear update event flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UPDATE);
 800100a:	687b      	ldr	r3, [r7, #4]
 800100c:	681b      	ldr	r3, [r3, #0]
 800100e:	2280      	movs	r2, #128	; 0x80
 8001010:	605a      	str	r2, [r3, #4]

      /* Update event Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->UpdateEventCallback(hlptim);
#else
      HAL_LPTIM_UpdateEventCallback(hlptim);
 8001012:	6878      	ldr	r0, [r7, #4]
 8001014:	f000 f85b 	bl	80010ce <HAL_LPTIM_UpdateEventCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }

  /* Successful APB bus write to repetition counter register */
  if (__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_REPOK) != RESET)
 8001018:	687b      	ldr	r3, [r7, #4]
 800101a:	681b      	ldr	r3, [r3, #0]
 800101c:	681b      	ldr	r3, [r3, #0]
 800101e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001022:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001026:	d10f      	bne.n	8001048 <HAL_LPTIM_IRQHandler+0x188>
  {
    if (__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_REPOK) != RESET)
 8001028:	687b      	ldr	r3, [r7, #4]
 800102a:	681b      	ldr	r3, [r3, #0]
 800102c:	689b      	ldr	r3, [r3, #8]
 800102e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001032:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001036:	d107      	bne.n	8001048 <HAL_LPTIM_IRQHandler+0x188>
    {
      /* Clear successful APB bus write to repetition counter flag */
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_REPOK);
 8001038:	687b      	ldr	r3, [r7, #4]
 800103a:	681b      	ldr	r3, [r3, #0]
 800103c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001040:	605a      	str	r2, [r3, #4]

      /* Successful APB bus write to repetition counter Callback */
#if (USE_HAL_LPTIM_REGISTER_CALLBACKS == 1)
      hlptim->RepCounterWriteCallback(hlptim);
#else
      HAL_LPTIM_RepCounterWriteCallback(hlptim);
 8001042:	6878      	ldr	r0, [r7, #4]
 8001044:	f000 f84c 	bl	80010e0 <HAL_LPTIM_RepCounterWriteCallback>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
    }
  }
}
 8001048:	bf00      	nop
 800104a:	3708      	adds	r7, #8
 800104c:	46bd      	mov	sp, r7
 800104e:	bd80      	pop	{r7, pc}

08001050 <HAL_LPTIM_CompareMatchCallback>:
  * @brief  Compare match callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_CompareMatchCallback(LPTIM_HandleTypeDef *hlptim)
{
 8001050:	b480      	push	{r7}
 8001052:	b083      	sub	sp, #12
 8001054:	af00      	add	r7, sp, #0
 8001056:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_CompareMatchCallback could be implemented in the user file
   */
}
 8001058:	bf00      	nop
 800105a:	370c      	adds	r7, #12
 800105c:	46bd      	mov	sp, r7
 800105e:	bc80      	pop	{r7}
 8001060:	4770      	bx	lr

08001062 <HAL_LPTIM_AutoReloadMatchCallback>:
  * @brief  Autoreload match callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_AutoReloadMatchCallback(LPTIM_HandleTypeDef *hlptim)
{
 8001062:	b480      	push	{r7}
 8001064:	b083      	sub	sp, #12
 8001066:	af00      	add	r7, sp, #0
 8001068:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_AutoReloadMatchCallback could be implemented in the user file
   */
}
 800106a:	bf00      	nop
 800106c:	370c      	adds	r7, #12
 800106e:	46bd      	mov	sp, r7
 8001070:	bc80      	pop	{r7}
 8001072:	4770      	bx	lr

08001074 <HAL_LPTIM_TriggerCallback>:
  * @brief  Trigger detected callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_TriggerCallback(LPTIM_HandleTypeDef *hlptim)
{
 8001074:	b480      	push	{r7}
 8001076:	b083      	sub	sp, #12
 8001078:	af00      	add	r7, sp, #0
 800107a:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_TriggerCallback could be implemented in the user file
   */
}
 800107c:	bf00      	nop
 800107e:	370c      	adds	r7, #12
 8001080:	46bd      	mov	sp, r7
 8001082:	bc80      	pop	{r7}
 8001084:	4770      	bx	lr

08001086 <HAL_LPTIM_CompareWriteCallback>:
  * @brief  Compare write callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_CompareWriteCallback(LPTIM_HandleTypeDef *hlptim)
{
 8001086:	b480      	push	{r7}
 8001088:	b083      	sub	sp, #12
 800108a:	af00      	add	r7, sp, #0
 800108c:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_CompareWriteCallback could be implemented in the user file
   */
}
 800108e:	bf00      	nop
 8001090:	370c      	adds	r7, #12
 8001092:	46bd      	mov	sp, r7
 8001094:	bc80      	pop	{r7}
 8001096:	4770      	bx	lr

08001098 <HAL_LPTIM_AutoReloadWriteCallback>:
  * @brief  Autoreload write callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_AutoReloadWriteCallback(LPTIM_HandleTypeDef *hlptim)
{
 8001098:	b480      	push	{r7}
 800109a:	b083      	sub	sp, #12
 800109c:	af00      	add	r7, sp, #0
 800109e:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_AutoReloadWriteCallback could be implemented in the user file
   */
}
 80010a0:	bf00      	nop
 80010a2:	370c      	adds	r7, #12
 80010a4:	46bd      	mov	sp, r7
 80010a6:	bc80      	pop	{r7}
 80010a8:	4770      	bx	lr

080010aa <HAL_LPTIM_DirectionUpCallback>:
  * @brief  Direction counter changed from Down to Up callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_DirectionUpCallback(LPTIM_HandleTypeDef *hlptim)
{
 80010aa:	b480      	push	{r7}
 80010ac:	b083      	sub	sp, #12
 80010ae:	af00      	add	r7, sp, #0
 80010b0:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_DirectionUpCallback could be implemented in the user file
   */
}
 80010b2:	bf00      	nop
 80010b4:	370c      	adds	r7, #12
 80010b6:	46bd      	mov	sp, r7
 80010b8:	bc80      	pop	{r7}
 80010ba:	4770      	bx	lr

080010bc <HAL_LPTIM_DirectionDownCallback>:
  * @brief  Direction counter changed from Up to Down callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_DirectionDownCallback(LPTIM_HandleTypeDef *hlptim)
{
 80010bc:	b480      	push	{r7}
 80010be:	b083      	sub	sp, #12
 80010c0:	af00      	add	r7, sp, #0
 80010c2:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_DirectionDownCallback could be implemented in the user file
   */
}
 80010c4:	bf00      	nop
 80010c6:	370c      	adds	r7, #12
 80010c8:	46bd      	mov	sp, r7
 80010ca:	bc80      	pop	{r7}
 80010cc:	4770      	bx	lr

080010ce <HAL_LPTIM_UpdateEventCallback>:
  * @brief Repetition counter underflowed (or contains zero) and LPTIM counter overflowed callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_UpdateEventCallback(LPTIM_HandleTypeDef *hlptim)
{
 80010ce:	b480      	push	{r7}
 80010d0:	b083      	sub	sp, #12
 80010d2:	af00      	add	r7, sp, #0
 80010d4:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_UpdateEventCallback could be implemented in the user file
   */
}
 80010d6:	bf00      	nop
 80010d8:	370c      	adds	r7, #12
 80010da:	46bd      	mov	sp, r7
 80010dc:	bc80      	pop	{r7}
 80010de:	4770      	bx	lr

080010e0 <HAL_LPTIM_RepCounterWriteCallback>:
  * @brief  Successful APB bus write to repetition counter register callback in non-blocking mode.
  * @param  hlptim LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_RepCounterWriteCallback(LPTIM_HandleTypeDef *hlptim)
{
 80010e0:	b480      	push	{r7}
 80010e2:	b083      	sub	sp, #12
 80010e4:	af00      	add	r7, sp, #0
 80010e6:	6078      	str	r0, [r7, #4]
  UNUSED(hlptim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LPTIM_RepCounterWriteCallback could be implemented in the user file
   */
}
 80010e8:	bf00      	nop
 80010ea:	370c      	adds	r7, #12
 80010ec:	46bd      	mov	sp, r7
 80010ee:	bc80      	pop	{r7}
 80010f0:	4770      	bx	lr

080010f2 <HAL_LPTIM_GetState>:
  * @brief  Return the LPTIM handle state.
  * @param  hlptim LPTIM handle
  * @retval HAL state
  */
HAL_LPTIM_StateTypeDef HAL_LPTIM_GetState(LPTIM_HandleTypeDef *hlptim)
{
 80010f2:	b480      	push	{r7}
 80010f4:	b083      	sub	sp, #12
 80010f6:	af00      	add	r7, sp, #0
 80010f8:	6078      	str	r0, [r7, #4]
  /* Return LPTIM handle state */
  return hlptim->State;
 80010fa:	687b      	ldr	r3, [r7, #4]
 80010fc:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 8001100:	b2db      	uxtb	r3, r3
}
 8001102:	4618      	mov	r0, r3
 8001104:	370c      	adds	r7, #12
 8001106:	46bd      	mov	sp, r7
 8001108:	bc80      	pop	{r7}
 800110a:	4770      	bx	lr

0800110c <LPTIM_WaitForFlag>:
  *                the configuration information for LPTIM module.
  * @param  flag   The lptim flag
  * @retval HAL status
  */
static HAL_StatusTypeDef LPTIM_WaitForFlag(LPTIM_HandleTypeDef *hlptim, uint32_t flag)
{
 800110c:	b480      	push	{r7}
 800110e:	b085      	sub	sp, #20
 8001110:	af00      	add	r7, sp, #0
 8001112:	6078      	str	r0, [r7, #4]
 8001114:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef result = HAL_OK;
 8001116:	2300      	movs	r3, #0
 8001118:	73fb      	strb	r3, [r7, #15]
  uint32_t count = TIMEOUT * (SystemCoreClock / 20UL / 1000UL);
 800111a:	4b12      	ldr	r3, [pc, #72]	; (8001164 <LPTIM_WaitForFlag+0x58>)
 800111c:	681b      	ldr	r3, [r3, #0]
 800111e:	4a12      	ldr	r2, [pc, #72]	; (8001168 <LPTIM_WaitForFlag+0x5c>)
 8001120:	fba2 2303 	umull	r2, r3, r2, r3
 8001124:	0b9b      	lsrs	r3, r3, #14
 8001126:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800112a:	fb02 f303 	mul.w	r3, r2, r3
 800112e:	60bb      	str	r3, [r7, #8]
  do
  {
    count--;
 8001130:	68bb      	ldr	r3, [r7, #8]
 8001132:	3b01      	subs	r3, #1
 8001134:	60bb      	str	r3, [r7, #8]
    if (count == 0UL)
 8001136:	68bb      	ldr	r3, [r7, #8]
 8001138:	2b00      	cmp	r3, #0
 800113a:	d101      	bne.n	8001140 <LPTIM_WaitForFlag+0x34>
    {
      result = HAL_TIMEOUT;
 800113c:	2303      	movs	r3, #3
 800113e:	73fb      	strb	r3, [r7, #15]
    }
  } while ((!(__HAL_LPTIM_GET_FLAG((hlptim), (flag)))) && (count != 0UL));
 8001140:	687b      	ldr	r3, [r7, #4]
 8001142:	681b      	ldr	r3, [r3, #0]
 8001144:	681a      	ldr	r2, [r3, #0]
 8001146:	683b      	ldr	r3, [r7, #0]
 8001148:	4013      	ands	r3, r2
 800114a:	683a      	ldr	r2, [r7, #0]
 800114c:	429a      	cmp	r2, r3
 800114e:	d002      	beq.n	8001156 <LPTIM_WaitForFlag+0x4a>
 8001150:	68bb      	ldr	r3, [r7, #8]
 8001152:	2b00      	cmp	r3, #0
 8001154:	d1ec      	bne.n	8001130 <LPTIM_WaitForFlag+0x24>

  return result;
 8001156:	7bfb      	ldrb	r3, [r7, #15]
}
 8001158:	4618      	mov	r0, r3
 800115a:	3714      	adds	r7, #20
 800115c:	46bd      	mov	sp, r7
 800115e:	bc80      	pop	{r7}
 8001160:	4770      	bx	lr
 8001162:	bf00      	nop
 8001164:	20000000 	.word	0x20000000
 8001168:	d1b71759 	.word	0xd1b71759

0800116c <LPTIM_Disable>:
  *         Please check Errata Sheet ES0335 for more details under "MCU may remain
  *         stuck in LPTIM interrupt when entering Stop mode" section.
  * @retval None
  */
void LPTIM_Disable(LPTIM_HandleTypeDef *hlptim)
{
 800116c:	b580      	push	{r7, lr}
 800116e:	b08a      	sub	sp, #40	; 0x28
 8001170:	af00      	add	r7, sp, #0
 8001172:	6078      	str	r0, [r7, #4]
  uint32_t tmpclksource = 0;
 8001174:	2300      	movs	r3, #0
 8001176:	627b      	str	r3, [r7, #36]	; 0x24
  __ASM volatile ("cpsid i" : : : "memory");
 8001178:	b672      	cpsid	i
}
 800117a:	bf00      	nop

  __disable_irq();

  /*********** Save LPTIM Config ***********/
  /* Save LPTIM source clock */
  switch ((uint32_t)hlptim->Instance)
 800117c:	687b      	ldr	r3, [r7, #4]
 800117e:	681b      	ldr	r3, [r3, #0]
 8001180:	4a8d      	ldr	r2, [pc, #564]	; (80013b8 <LPTIM_Disable+0x24c>)
 8001182:	4293      	cmp	r3, r2
 8001184:	d015      	beq.n	80011b2 <LPTIM_Disable+0x46>
 8001186:	4a8c      	ldr	r2, [pc, #560]	; (80013b8 <LPTIM_Disable+0x24c>)
 8001188:	4293      	cmp	r3, r2
 800118a:	d818      	bhi.n	80011be <LPTIM_Disable+0x52>
 800118c:	4a8b      	ldr	r2, [pc, #556]	; (80013bc <LPTIM_Disable+0x250>)
 800118e:	4293      	cmp	r3, r2
 8001190:	d003      	beq.n	800119a <LPTIM_Disable+0x2e>
 8001192:	4a8b      	ldr	r2, [pc, #556]	; (80013c0 <LPTIM_Disable+0x254>)
 8001194:	4293      	cmp	r3, r2
 8001196:	d006      	beq.n	80011a6 <LPTIM_Disable+0x3a>
      break;
    case LPTIM3_BASE:
      tmpclksource = __HAL_RCC_GET_LPTIM3_SOURCE();
      break;
    default:
      break;
 8001198:	e011      	b.n	80011be <LPTIM_Disable+0x52>
      tmpclksource = __HAL_RCC_GET_LPTIM1_SOURCE();
 800119a:	f44f 2040 	mov.w	r0, #786432	; 0xc0000
 800119e:	f7ff fccd 	bl	8000b3c <LL_RCC_GetLPTIMClockSource>
 80011a2:	6278      	str	r0, [r7, #36]	; 0x24
      break;
 80011a4:	e00c      	b.n	80011c0 <LPTIM_Disable+0x54>
      tmpclksource = __HAL_RCC_GET_LPTIM2_SOURCE();
 80011a6:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
 80011aa:	f7ff fcc7 	bl	8000b3c <LL_RCC_GetLPTIMClockSource>
 80011ae:	6278      	str	r0, [r7, #36]	; 0x24
      break;
 80011b0:	e006      	b.n	80011c0 <LPTIM_Disable+0x54>
      tmpclksource = __HAL_RCC_GET_LPTIM3_SOURCE();
 80011b2:	f44f 0040 	mov.w	r0, #12582912	; 0xc00000
 80011b6:	f7ff fcc1 	bl	8000b3c <LL_RCC_GetLPTIMClockSource>
 80011ba:	6278      	str	r0, [r7, #36]	; 0x24
      break;
 80011bc:	e000      	b.n	80011c0 <LPTIM_Disable+0x54>
      break;
 80011be:	bf00      	nop
  }

  /* Save LPTIM configuration registers */
  tmpIER = hlptim->Instance->IER;
 80011c0:	687b      	ldr	r3, [r7, #4]
 80011c2:	681b      	ldr	r3, [r3, #0]
 80011c4:	689b      	ldr	r3, [r3, #8]
 80011c6:	623b      	str	r3, [r7, #32]
  tmpCFGR = hlptim->Instance->CFGR;
 80011c8:	687b      	ldr	r3, [r7, #4]
 80011ca:	681b      	ldr	r3, [r3, #0]
 80011cc:	68db      	ldr	r3, [r3, #12]
 80011ce:	61fb      	str	r3, [r7, #28]
  tmpCMP = hlptim->Instance->CMP;
 80011d0:	687b      	ldr	r3, [r7, #4]
 80011d2:	681b      	ldr	r3, [r3, #0]
 80011d4:	695b      	ldr	r3, [r3, #20]
 80011d6:	61bb      	str	r3, [r7, #24]
  tmpARR = hlptim->Instance->ARR;
 80011d8:	687b      	ldr	r3, [r7, #4]
 80011da:	681b      	ldr	r3, [r3, #0]
 80011dc:	699b      	ldr	r3, [r3, #24]
 80011de:	617b      	str	r3, [r7, #20]
  tmpOR = hlptim->Instance->OR;
 80011e0:	687b      	ldr	r3, [r7, #4]
 80011e2:	681b      	ldr	r3, [r3, #0]
 80011e4:	6a1b      	ldr	r3, [r3, #32]
 80011e6:	613b      	str	r3, [r7, #16]
  tmpRCR = hlptim->Instance->RCR;
 80011e8:	687b      	ldr	r3, [r7, #4]
 80011ea:	681b      	ldr	r3, [r3, #0]
 80011ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80011ee:	60fb      	str	r3, [r7, #12]

  /*********** Reset LPTIM ***********/
  switch ((uint32_t)hlptim->Instance)
 80011f0:	687b      	ldr	r3, [r7, #4]
 80011f2:	681b      	ldr	r3, [r3, #0]
 80011f4:	4a70      	ldr	r2, [pc, #448]	; (80013b8 <LPTIM_Disable+0x24c>)
 80011f6:	4293      	cmp	r3, r2
 80011f8:	d019      	beq.n	800122e <LPTIM_Disable+0xc2>
 80011fa:	4a6f      	ldr	r2, [pc, #444]	; (80013b8 <LPTIM_Disable+0x24c>)
 80011fc:	4293      	cmp	r3, r2
 80011fe:	d81d      	bhi.n	800123c <LPTIM_Disable+0xd0>
 8001200:	4a6e      	ldr	r2, [pc, #440]	; (80013bc <LPTIM_Disable+0x250>)
 8001202:	4293      	cmp	r3, r2
 8001204:	d003      	beq.n	800120e <LPTIM_Disable+0xa2>
 8001206:	4a6e      	ldr	r2, [pc, #440]	; (80013c0 <LPTIM_Disable+0x254>)
 8001208:	4293      	cmp	r3, r2
 800120a:	d009      	beq.n	8001220 <LPTIM_Disable+0xb4>
    case LPTIM3_BASE:
      __HAL_RCC_LPTIM3_FORCE_RESET();
      __HAL_RCC_LPTIM3_RELEASE_RESET();
      break;
    default:
      break;
 800120c:	e016      	b.n	800123c <LPTIM_Disable+0xd0>
      __HAL_RCC_LPTIM1_FORCE_RESET();
 800120e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8001212:	f7ff fca5 	bl	8000b60 <LL_APB1_GRP1_ForceReset>
      __HAL_RCC_LPTIM1_RELEASE_RESET();
 8001216:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800121a:	f7ff fcc3 	bl	8000ba4 <LL_APB1_GRP1_ReleaseReset>
      break;
 800121e:	e00e      	b.n	800123e <LPTIM_Disable+0xd2>
      __HAL_RCC_LPTIM2_FORCE_RESET();
 8001220:	2020      	movs	r0, #32
 8001222:	f7ff fcae 	bl	8000b82 <LL_APB1_GRP2_ForceReset>
      __HAL_RCC_LPTIM2_RELEASE_RESET();
 8001226:	2020      	movs	r0, #32
 8001228:	f7ff fcce 	bl	8000bc8 <LL_APB1_GRP2_ReleaseReset>
      break;
 800122c:	e007      	b.n	800123e <LPTIM_Disable+0xd2>
      __HAL_RCC_LPTIM3_FORCE_RESET();
 800122e:	2040      	movs	r0, #64	; 0x40
 8001230:	f7ff fca7 	bl	8000b82 <LL_APB1_GRP2_ForceReset>
      __HAL_RCC_LPTIM3_RELEASE_RESET();
 8001234:	2040      	movs	r0, #64	; 0x40
 8001236:	f7ff fcc7 	bl	8000bc8 <LL_APB1_GRP2_ReleaseReset>
      break;
 800123a:	e000      	b.n	800123e <LPTIM_Disable+0xd2>
      break;
 800123c:	bf00      	nop
  }

  /*********** Restore LPTIM Config ***********/
  if ((tmpCMP != 0UL) || (tmpARR != 0UL) || (tmpRCR != 0UL))
 800123e:	69bb      	ldr	r3, [r7, #24]
 8001240:	2b00      	cmp	r3, #0
 8001242:	d106      	bne.n	8001252 <LPTIM_Disable+0xe6>
 8001244:	697b      	ldr	r3, [r7, #20]
 8001246:	2b00      	cmp	r3, #0
 8001248:	d103      	bne.n	8001252 <LPTIM_Disable+0xe6>
 800124a:	68fb      	ldr	r3, [r7, #12]
 800124c:	2b00      	cmp	r3, #0
 800124e:	f000 8096 	beq.w	800137e <LPTIM_Disable+0x212>
  {
    /* Force LPTIM source kernel clock from APB */
    switch ((uint32_t)hlptim->Instance)
 8001252:	687b      	ldr	r3, [r7, #4]
 8001254:	681b      	ldr	r3, [r3, #0]
 8001256:	4a58      	ldr	r2, [pc, #352]	; (80013b8 <LPTIM_Disable+0x24c>)
 8001258:	4293      	cmp	r3, r2
 800125a:	d013      	beq.n	8001284 <LPTIM_Disable+0x118>
 800125c:	4a56      	ldr	r2, [pc, #344]	; (80013b8 <LPTIM_Disable+0x24c>)
 800125e:	4293      	cmp	r3, r2
 8001260:	d815      	bhi.n	800128e <LPTIM_Disable+0x122>
 8001262:	4a56      	ldr	r2, [pc, #344]	; (80013bc <LPTIM_Disable+0x250>)
 8001264:	4293      	cmp	r3, r2
 8001266:	d003      	beq.n	8001270 <LPTIM_Disable+0x104>
 8001268:	4a55      	ldr	r2, [pc, #340]	; (80013c0 <LPTIM_Disable+0x254>)
 800126a:	4293      	cmp	r3, r2
 800126c:	d005      	beq.n	800127a <LPTIM_Disable+0x10e>
        break;
      case LPTIM3_BASE:
        __HAL_RCC_LPTIM3_CONFIG(RCC_LPTIM3CLKSOURCE_PCLK1);
        break;
      default:
        break;
 800126e:	e00e      	b.n	800128e <LPTIM_Disable+0x122>
        __HAL_RCC_LPTIM1_CONFIG(RCC_LPTIM1CLKSOURCE_PCLK1);
 8001270:	f44f 2040 	mov.w	r0, #786432	; 0xc0000
 8001274:	f7ff fc49 	bl	8000b0a <LL_RCC_SetLPTIMClockSource>
        break;
 8001278:	e00a      	b.n	8001290 <LPTIM_Disable+0x124>
        __HAL_RCC_LPTIM2_CONFIG(RCC_LPTIM2CLKSOURCE_PCLK1);
 800127a:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
 800127e:	f7ff fc44 	bl	8000b0a <LL_RCC_SetLPTIMClockSource>
        break;
 8001282:	e005      	b.n	8001290 <LPTIM_Disable+0x124>
        __HAL_RCC_LPTIM3_CONFIG(RCC_LPTIM3CLKSOURCE_PCLK1);
 8001284:	f44f 0040 	mov.w	r0, #12582912	; 0xc00000
 8001288:	f7ff fc3f 	bl	8000b0a <LL_RCC_SetLPTIMClockSource>
        break;
 800128c:	e000      	b.n	8001290 <LPTIM_Disable+0x124>
        break;
 800128e:	bf00      	nop
    }

    if (tmpCMP != 0UL)
 8001290:	69bb      	ldr	r3, [r7, #24]
 8001292:	2b00      	cmp	r3, #0
 8001294:	d01a      	beq.n	80012cc <LPTIM_Disable+0x160>
    {
      /* Restore CMP register (LPTIM should be enabled first) */
      hlptim->Instance->CR |= LPTIM_CR_ENABLE;
 8001296:	687b      	ldr	r3, [r7, #4]
 8001298:	681b      	ldr	r3, [r3, #0]
 800129a:	691a      	ldr	r2, [r3, #16]
 800129c:	687b      	ldr	r3, [r7, #4]
 800129e:	681b      	ldr	r3, [r3, #0]
 80012a0:	f042 0201 	orr.w	r2, r2, #1
 80012a4:	611a      	str	r2, [r3, #16]
      hlptim->Instance->CMP = tmpCMP;
 80012a6:	687b      	ldr	r3, [r7, #4]
 80012a8:	681b      	ldr	r3, [r3, #0]
 80012aa:	69ba      	ldr	r2, [r7, #24]
 80012ac:	615a      	str	r2, [r3, #20]

      /* Wait for the completion of the write operation to the LPTIM_CMP register */
      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_CMPOK) == HAL_TIMEOUT)
 80012ae:	2108      	movs	r1, #8
 80012b0:	6878      	ldr	r0, [r7, #4]
 80012b2:	f7ff ff2b 	bl	800110c <LPTIM_WaitForFlag>
 80012b6:	4603      	mov	r3, r0
 80012b8:	2b03      	cmp	r3, #3
 80012ba:	d103      	bne.n	80012c4 <LPTIM_Disable+0x158>
      {
        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;
 80012bc:	687b      	ldr	r3, [r7, #4]
 80012be:	2203      	movs	r2, #3
 80012c0:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
      }
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);
 80012c4:	687b      	ldr	r3, [r7, #4]
 80012c6:	681b      	ldr	r3, [r3, #0]
 80012c8:	2208      	movs	r2, #8
 80012ca:	605a      	str	r2, [r3, #4]
    }

    if (tmpARR != 0UL)
 80012cc:	697b      	ldr	r3, [r7, #20]
 80012ce:	2b00      	cmp	r3, #0
 80012d0:	d01a      	beq.n	8001308 <LPTIM_Disable+0x19c>
    {
      /* Restore ARR register (LPTIM should be enabled first) */
      hlptim->Instance->CR |= LPTIM_CR_ENABLE;
 80012d2:	687b      	ldr	r3, [r7, #4]
 80012d4:	681b      	ldr	r3, [r3, #0]
 80012d6:	691a      	ldr	r2, [r3, #16]
 80012d8:	687b      	ldr	r3, [r7, #4]
 80012da:	681b      	ldr	r3, [r3, #0]
 80012dc:	f042 0201 	orr.w	r2, r2, #1
 80012e0:	611a      	str	r2, [r3, #16]
      hlptim->Instance->ARR = tmpARR;
 80012e2:	687b      	ldr	r3, [r7, #4]
 80012e4:	681b      	ldr	r3, [r3, #0]
 80012e6:	697a      	ldr	r2, [r7, #20]
 80012e8:	619a      	str	r2, [r3, #24]

      /* Wait for the completion of the write operation to the LPTIM_ARR register */
      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_ARROK) == HAL_TIMEOUT)
 80012ea:	2110      	movs	r1, #16
 80012ec:	6878      	ldr	r0, [r7, #4]
 80012ee:	f7ff ff0d 	bl	800110c <LPTIM_WaitForFlag>
 80012f2:	4603      	mov	r3, r0
 80012f4:	2b03      	cmp	r3, #3
 80012f6:	d103      	bne.n	8001300 <LPTIM_Disable+0x194>
      {
        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;
 80012f8:	687b      	ldr	r3, [r7, #4]
 80012fa:	2203      	movs	r2, #3
 80012fc:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
      }

      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);
 8001300:	687b      	ldr	r3, [r7, #4]
 8001302:	681b      	ldr	r3, [r3, #0]
 8001304:	2210      	movs	r2, #16
 8001306:	605a      	str	r2, [r3, #4]
    }

    if (tmpRCR != 0UL)
 8001308:	68fb      	ldr	r3, [r7, #12]
 800130a:	2b00      	cmp	r3, #0
 800130c:	d01c      	beq.n	8001348 <LPTIM_Disable+0x1dc>
    {
      /* Restore RCR register (LPTIM should be enabled first) */
      hlptim->Instance->CR |= LPTIM_CR_ENABLE;
 800130e:	687b      	ldr	r3, [r7, #4]
 8001310:	681b      	ldr	r3, [r3, #0]
 8001312:	691a      	ldr	r2, [r3, #16]
 8001314:	687b      	ldr	r3, [r7, #4]
 8001316:	681b      	ldr	r3, [r3, #0]
 8001318:	f042 0201 	orr.w	r2, r2, #1
 800131c:	611a      	str	r2, [r3, #16]
      hlptim->Instance->RCR = tmpRCR;
 800131e:	687b      	ldr	r3, [r7, #4]
 8001320:	681b      	ldr	r3, [r3, #0]
 8001322:	68fa      	ldr	r2, [r7, #12]
 8001324:	629a      	str	r2, [r3, #40]	; 0x28

      /* Wait for the completion of the write operation to the LPTIM_RCR register */
      if (LPTIM_WaitForFlag(hlptim, LPTIM_FLAG_REPOK) == HAL_TIMEOUT)
 8001326:	f44f 7180 	mov.w	r1, #256	; 0x100
 800132a:	6878      	ldr	r0, [r7, #4]
 800132c:	f7ff feee 	bl	800110c <LPTIM_WaitForFlag>
 8001330:	4603      	mov	r3, r0
 8001332:	2b03      	cmp	r3, #3
 8001334:	d103      	bne.n	800133e <LPTIM_Disable+0x1d2>
      {
        hlptim->State = HAL_LPTIM_STATE_TIMEOUT;
 8001336:	687b      	ldr	r3, [r7, #4]
 8001338:	2203      	movs	r2, #3
 800133a:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
      }
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_REPOK);
 800133e:	687b      	ldr	r3, [r7, #4]
 8001340:	681b      	ldr	r3, [r3, #0]
 8001342:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001346:	605a      	str	r2, [r3, #4]
    }

    /* Restore LPTIM source kernel clock */
    switch ((uint32_t)hlptim->Instance)
 8001348:	687b      	ldr	r3, [r7, #4]
 800134a:	681b      	ldr	r3, [r3, #0]
 800134c:	4a1a      	ldr	r2, [pc, #104]	; (80013b8 <LPTIM_Disable+0x24c>)
 800134e:	4293      	cmp	r3, r2
 8001350:	d011      	beq.n	8001376 <LPTIM_Disable+0x20a>
 8001352:	4a19      	ldr	r2, [pc, #100]	; (80013b8 <LPTIM_Disable+0x24c>)
 8001354:	4293      	cmp	r3, r2
 8001356:	d814      	bhi.n	8001382 <LPTIM_Disable+0x216>
 8001358:	4a18      	ldr	r2, [pc, #96]	; (80013bc <LPTIM_Disable+0x250>)
 800135a:	4293      	cmp	r3, r2
 800135c:	d003      	beq.n	8001366 <LPTIM_Disable+0x1fa>
 800135e:	4a18      	ldr	r2, [pc, #96]	; (80013c0 <LPTIM_Disable+0x254>)
 8001360:	4293      	cmp	r3, r2
 8001362:	d004      	beq.n	800136e <LPTIM_Disable+0x202>
        break;
      case LPTIM3_BASE:
        __HAL_RCC_LPTIM3_CONFIG(tmpclksource);
        break;
      default:
        break;
 8001364:	e00d      	b.n	8001382 <LPTIM_Disable+0x216>
        __HAL_RCC_LPTIM1_CONFIG(tmpclksource);
 8001366:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8001368:	f7ff fbcf 	bl	8000b0a <LL_RCC_SetLPTIMClockSource>
        break;
 800136c:	e00a      	b.n	8001384 <LPTIM_Disable+0x218>
        __HAL_RCC_LPTIM2_CONFIG(tmpclksource);
 800136e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8001370:	f7ff fbcb 	bl	8000b0a <LL_RCC_SetLPTIMClockSource>
        break;
 8001374:	e006      	b.n	8001384 <LPTIM_Disable+0x218>
        __HAL_RCC_LPTIM3_CONFIG(tmpclksource);
 8001376:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8001378:	f7ff fbc7 	bl	8000b0a <LL_RCC_SetLPTIMClockSource>
        break;
 800137c:	e002      	b.n	8001384 <LPTIM_Disable+0x218>
    }
  }
 800137e:	bf00      	nop
 8001380:	e000      	b.n	8001384 <LPTIM_Disable+0x218>
        break;
 8001382:	bf00      	nop

  /* Restore configuration registers (LPTIM should be disabled first) */
  hlptim->Instance->CR &= ~(LPTIM_CR_ENABLE);
 8001384:	687b      	ldr	r3, [r7, #4]
 8001386:	681b      	ldr	r3, [r3, #0]
 8001388:	691a      	ldr	r2, [r3, #16]
 800138a:	687b      	ldr	r3, [r7, #4]
 800138c:	681b      	ldr	r3, [r3, #0]
 800138e:	f022 0201 	bic.w	r2, r2, #1
 8001392:	611a      	str	r2, [r3, #16]
  hlptim->Instance->IER = tmpIER;
 8001394:	687b      	ldr	r3, [r7, #4]
 8001396:	681b      	ldr	r3, [r3, #0]
 8001398:	6a3a      	ldr	r2, [r7, #32]
 800139a:	609a      	str	r2, [r3, #8]
  hlptim->Instance->CFGR = tmpCFGR;
 800139c:	687b      	ldr	r3, [r7, #4]
 800139e:	681b      	ldr	r3, [r3, #0]
 80013a0:	69fa      	ldr	r2, [r7, #28]
 80013a2:	60da      	str	r2, [r3, #12]
  hlptim->Instance->OR = tmpOR;
 80013a4:	687b      	ldr	r3, [r7, #4]
 80013a6:	681b      	ldr	r3, [r3, #0]
 80013a8:	693a      	ldr	r2, [r7, #16]
 80013aa:	621a      	str	r2, [r3, #32]
  __ASM volatile ("cpsie i" : : : "memory");
 80013ac:	b662      	cpsie	i
}
 80013ae:	bf00      	nop

  __enable_irq();
}
 80013b0:	bf00      	nop
 80013b2:	3728      	adds	r7, #40	; 0x28
 80013b4:	46bd      	mov	sp, r7
 80013b6:	bd80      	pop	{r7, pc}
 80013b8:	40009800 	.word	0x40009800
 80013bc:	40007c00 	.word	0x40007c00
 80013c0:	40009400 	.word	0x40009400

080013c4 <HAL_PWR_EnableBkUpAccess>:
  * @note   LSEON bit that switches on and off the LSE crystal belongs as well to the
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 80013c4:	b480      	push	{r7}
 80013c6:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80013c8:	4b04      	ldr	r3, [pc, #16]	; (80013dc <HAL_PWR_EnableBkUpAccess+0x18>)
 80013ca:	681b      	ldr	r3, [r3, #0]
 80013cc:	4a03      	ldr	r2, [pc, #12]	; (80013dc <HAL_PWR_EnableBkUpAccess+0x18>)
 80013ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80013d2:	6013      	str	r3, [r2, #0]
}
 80013d4:	bf00      	nop
 80013d6:	46bd      	mov	sp, r7
 80013d8:	bc80      	pop	{r7}
 80013da:	4770      	bx	lr
 80013dc:	58000400 	.word	0x58000400

080013e0 <HAL_PWREx_GetVoltageRange>:
/**
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 80013e0:	b480      	push	{r7}
 80013e2:	af00      	add	r7, sp, #0
  return (PWR->CR1 & PWR_CR1_VOS);
 80013e4:	4b03      	ldr	r3, [pc, #12]	; (80013f4 <HAL_PWREx_GetVoltageRange+0x14>)
 80013e6:	681b      	ldr	r3, [r3, #0]
 80013e8:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
}
 80013ec:	4618      	mov	r0, r3
 80013ee:	46bd      	mov	sp, r7
 80013f0:	bc80      	pop	{r7}
 80013f2:	4770      	bx	lr
 80013f4:	58000400 	.word	0x58000400

080013f8 <HAL_PWREx_EnterSTOP2Mode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop mode with WFI instruction
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWREx_EnterSTOP2Mode(uint8_t STOPEntry)
{
 80013f8:	b480      	push	{r7}
 80013fa:	b083      	sub	sp, #12
 80013fc:	af00      	add	r7, sp, #0
 80013fe:	4603      	mov	r3, r0
 8001400:	71fb      	strb	r3, [r7, #7]
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 8001402:	4b10      	ldr	r3, [pc, #64]	; (8001444 <HAL_PWREx_EnterSTOP2Mode+0x4c>)
 8001404:	681b      	ldr	r3, [r3, #0]
 8001406:	f023 0307 	bic.w	r3, r3, #7
 800140a:	4a0e      	ldr	r2, [pc, #56]	; (8001444 <HAL_PWREx_EnterSTOP2Mode+0x4c>)
 800140c:	f043 0302 	orr.w	r3, r3, #2
 8001410:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8001412:	4b0d      	ldr	r3, [pc, #52]	; (8001448 <HAL_PWREx_EnterSTOP2Mode+0x50>)
 8001414:	691b      	ldr	r3, [r3, #16]
 8001416:	4a0c      	ldr	r2, [pc, #48]	; (8001448 <HAL_PWREx_EnterSTOP2Mode+0x50>)
 8001418:	f043 0304 	orr.w	r3, r3, #4
 800141c:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 800141e:	79fb      	ldrb	r3, [r7, #7]
 8001420:	2b01      	cmp	r3, #1
 8001422:	d101      	bne.n	8001428 <HAL_PWREx_EnterSTOP2Mode+0x30>
  {
    /* Request Wait For Interrupt */
    __WFI();
 8001424:	bf30      	wfi
 8001426:	e002      	b.n	800142e <HAL_PWREx_EnterSTOP2Mode+0x36>
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 8001428:	bf40      	sev
    __WFE();
 800142a:	bf20      	wfe
    __WFE();
 800142c:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800142e:	4b06      	ldr	r3, [pc, #24]	; (8001448 <HAL_PWREx_EnterSTOP2Mode+0x50>)
 8001430:	691b      	ldr	r3, [r3, #16]
 8001432:	4a05      	ldr	r2, [pc, #20]	; (8001448 <HAL_PWREx_EnterSTOP2Mode+0x50>)
 8001434:	f023 0304 	bic.w	r3, r3, #4
 8001438:	6113      	str	r3, [r2, #16]
}
 800143a:	bf00      	nop
 800143c:	370c      	adds	r7, #12
 800143e:	46bd      	mov	sp, r7
 8001440:	bc80      	pop	{r7}
 8001442:	4770      	bx	lr
 8001444:	58000400 	.word	0x58000400
 8001448:	e000ed00 	.word	0xe000ed00

0800144c <LL_PWR_IsEnabledBkUpAccess>:
  * @brief  Check if the backup domain is enabled
  * @rmtoll CR1          DBP           LL_PWR_IsEnabledBkUpAccess
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_PWR_IsEnabledBkUpAccess(void)
{
 800144c:	b480      	push	{r7}
 800144e:	af00      	add	r7, sp, #0
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 8001450:	4b06      	ldr	r3, [pc, #24]	; (800146c <LL_PWR_IsEnabledBkUpAccess+0x20>)
 8001452:	681b      	ldr	r3, [r3, #0]
 8001454:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001458:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800145c:	d101      	bne.n	8001462 <LL_PWR_IsEnabledBkUpAccess+0x16>
 800145e:	2301      	movs	r3, #1
 8001460:	e000      	b.n	8001464 <LL_PWR_IsEnabledBkUpAccess+0x18>
 8001462:	2300      	movs	r3, #0
}
 8001464:	4618      	mov	r0, r3
 8001466:	46bd      	mov	sp, r7
 8001468:	bc80      	pop	{r7}
 800146a:	4770      	bx	lr
 800146c:	58000400 	.word	0x58000400

08001470 <LL_RCC_HSE_EnableTcxo>:
{
 8001470:	b480      	push	{r7}
 8001472:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 8001474:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001478:	681b      	ldr	r3, [r3, #0]
 800147a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800147e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001482:	6013      	str	r3, [r2, #0]
}
 8001484:	bf00      	nop
 8001486:	46bd      	mov	sp, r7
 8001488:	bc80      	pop	{r7}
 800148a:	4770      	bx	lr

0800148c <LL_RCC_HSE_DisableTcxo>:
{
 800148c:	b480      	push	{r7}
 800148e:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 8001490:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001494:	681b      	ldr	r3, [r3, #0]
 8001496:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800149a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800149e:	6013      	str	r3, [r2, #0]
}
 80014a0:	bf00      	nop
 80014a2:	46bd      	mov	sp, r7
 80014a4:	bc80      	pop	{r7}
 80014a6:	4770      	bx	lr

080014a8 <LL_RCC_HSE_IsEnabledDiv2>:
{
 80014a8:	b480      	push	{r7}
 80014aa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 80014ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014b0:	681b      	ldr	r3, [r3, #0]
 80014b2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80014b6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80014ba:	d101      	bne.n	80014c0 <LL_RCC_HSE_IsEnabledDiv2+0x18>
 80014bc:	2301      	movs	r3, #1
 80014be:	e000      	b.n	80014c2 <LL_RCC_HSE_IsEnabledDiv2+0x1a>
 80014c0:	2300      	movs	r3, #0
}
 80014c2:	4618      	mov	r0, r3
 80014c4:	46bd      	mov	sp, r7
 80014c6:	bc80      	pop	{r7}
 80014c8:	4770      	bx	lr

080014ca <LL_RCC_HSE_Enable>:
{
 80014ca:	b480      	push	{r7}
 80014cc:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 80014ce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80014d8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80014dc:	6013      	str	r3, [r2, #0]
}
 80014de:	bf00      	nop
 80014e0:	46bd      	mov	sp, r7
 80014e2:	bc80      	pop	{r7}
 80014e4:	4770      	bx	lr

080014e6 <LL_RCC_HSE_Disable>:
{
 80014e6:	b480      	push	{r7}
 80014e8:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 80014ea:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014ee:	681b      	ldr	r3, [r3, #0]
 80014f0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80014f4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80014f8:	6013      	str	r3, [r2, #0]
}
 80014fa:	bf00      	nop
 80014fc:	46bd      	mov	sp, r7
 80014fe:	bc80      	pop	{r7}
 8001500:	4770      	bx	lr

08001502 <LL_RCC_HSE_IsReady>:
{
 8001502:	b480      	push	{r7}
 8001504:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8001506:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800150a:	681b      	ldr	r3, [r3, #0]
 800150c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001510:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8001514:	d101      	bne.n	800151a <LL_RCC_HSE_IsReady+0x18>
 8001516:	2301      	movs	r3, #1
 8001518:	e000      	b.n	800151c <LL_RCC_HSE_IsReady+0x1a>
 800151a:	2300      	movs	r3, #0
}
 800151c:	4618      	mov	r0, r3
 800151e:	46bd      	mov	sp, r7
 8001520:	bc80      	pop	{r7}
 8001522:	4770      	bx	lr

08001524 <LL_RCC_HSI_Enable>:
{
 8001524:	b480      	push	{r7}
 8001526:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8001528:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800152c:	681b      	ldr	r3, [r3, #0]
 800152e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001532:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001536:	6013      	str	r3, [r2, #0]
}
 8001538:	bf00      	nop
 800153a:	46bd      	mov	sp, r7
 800153c:	bc80      	pop	{r7}
 800153e:	4770      	bx	lr

08001540 <LL_RCC_HSI_Disable>:
{
 8001540:	b480      	push	{r7}
 8001542:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 8001544:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001548:	681b      	ldr	r3, [r3, #0]
 800154a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800154e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001552:	6013      	str	r3, [r2, #0]
}
 8001554:	bf00      	nop
 8001556:	46bd      	mov	sp, r7
 8001558:	bc80      	pop	{r7}
 800155a:	4770      	bx	lr

0800155c <LL_RCC_HSI_IsReady>:
{
 800155c:	b480      	push	{r7}
 800155e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8001560:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001564:	681b      	ldr	r3, [r3, #0]
 8001566:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800156a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800156e:	d101      	bne.n	8001574 <LL_RCC_HSI_IsReady+0x18>
 8001570:	2301      	movs	r3, #1
 8001572:	e000      	b.n	8001576 <LL_RCC_HSI_IsReady+0x1a>
 8001574:	2300      	movs	r3, #0
}
 8001576:	4618      	mov	r0, r3
 8001578:	46bd      	mov	sp, r7
 800157a:	bc80      	pop	{r7}
 800157c:	4770      	bx	lr

0800157e <LL_RCC_HSI_SetCalibTrimming>:
{
 800157e:	b480      	push	{r7}
 8001580:	b083      	sub	sp, #12
 8001582:	af00      	add	r7, sp, #0
 8001584:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8001586:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800158a:	685b      	ldr	r3, [r3, #4]
 800158c:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8001590:	687b      	ldr	r3, [r7, #4]
 8001592:	061b      	lsls	r3, r3, #24
 8001594:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001598:	4313      	orrs	r3, r2
 800159a:	604b      	str	r3, [r1, #4]
}
 800159c:	bf00      	nop
 800159e:	370c      	adds	r7, #12
 80015a0:	46bd      	mov	sp, r7
 80015a2:	bc80      	pop	{r7}
 80015a4:	4770      	bx	lr

080015a6 <LL_RCC_LSE_IsReady>:
{
 80015a6:	b480      	push	{r7}
 80015a8:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 80015aa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80015ae:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80015b2:	f003 0302 	and.w	r3, r3, #2
 80015b6:	2b02      	cmp	r3, #2
 80015b8:	d101      	bne.n	80015be <LL_RCC_LSE_IsReady+0x18>
 80015ba:	2301      	movs	r3, #1
 80015bc:	e000      	b.n	80015c0 <LL_RCC_LSE_IsReady+0x1a>
 80015be:	2300      	movs	r3, #0
}
 80015c0:	4618      	mov	r0, r3
 80015c2:	46bd      	mov	sp, r7
 80015c4:	bc80      	pop	{r7}
 80015c6:	4770      	bx	lr

080015c8 <LL_RCC_LSI_Enable>:
{
 80015c8:	b480      	push	{r7}
 80015ca:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 80015cc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80015d0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80015d4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80015d8:	f043 0301 	orr.w	r3, r3, #1
 80015dc:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 80015e0:	bf00      	nop
 80015e2:	46bd      	mov	sp, r7
 80015e4:	bc80      	pop	{r7}
 80015e6:	4770      	bx	lr

080015e8 <LL_RCC_LSI_Disable>:
{
 80015e8:	b480      	push	{r7}
 80015ea:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 80015ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80015f0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80015f4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80015f8:	f023 0301 	bic.w	r3, r3, #1
 80015fc:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 8001600:	bf00      	nop
 8001602:	46bd      	mov	sp, r7
 8001604:	bc80      	pop	{r7}
 8001606:	4770      	bx	lr

08001608 <LL_RCC_LSI_IsReady>:
{
 8001608:	b480      	push	{r7}
 800160a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 800160c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001610:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8001614:	f003 0302 	and.w	r3, r3, #2
 8001618:	2b02      	cmp	r3, #2
 800161a:	d101      	bne.n	8001620 <LL_RCC_LSI_IsReady+0x18>
 800161c:	2301      	movs	r3, #1
 800161e:	e000      	b.n	8001622 <LL_RCC_LSI_IsReady+0x1a>
 8001620:	2300      	movs	r3, #0
}
 8001622:	4618      	mov	r0, r3
 8001624:	46bd      	mov	sp, r7
 8001626:	bc80      	pop	{r7}
 8001628:	4770      	bx	lr

0800162a <LL_RCC_MSI_Enable>:
{
 800162a:	b480      	push	{r7}
 800162c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSION);
 800162e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001632:	681b      	ldr	r3, [r3, #0]
 8001634:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001638:	f043 0301 	orr.w	r3, r3, #1
 800163c:	6013      	str	r3, [r2, #0]
}
 800163e:	bf00      	nop
 8001640:	46bd      	mov	sp, r7
 8001642:	bc80      	pop	{r7}
 8001644:	4770      	bx	lr

08001646 <LL_RCC_MSI_Disable>:
{
 8001646:	b480      	push	{r7}
 8001648:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 800164a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800164e:	681b      	ldr	r3, [r3, #0]
 8001650:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001654:	f023 0301 	bic.w	r3, r3, #1
 8001658:	6013      	str	r3, [r2, #0]
}
 800165a:	bf00      	nop
 800165c:	46bd      	mov	sp, r7
 800165e:	bc80      	pop	{r7}
 8001660:	4770      	bx	lr

08001662 <LL_RCC_MSI_IsReady>:
{
 8001662:	b480      	push	{r7}
 8001664:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8001666:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800166a:	681b      	ldr	r3, [r3, #0]
 800166c:	f003 0302 	and.w	r3, r3, #2
 8001670:	2b02      	cmp	r3, #2
 8001672:	d101      	bne.n	8001678 <LL_RCC_MSI_IsReady+0x16>
 8001674:	2301      	movs	r3, #1
 8001676:	e000      	b.n	800167a <LL_RCC_MSI_IsReady+0x18>
 8001678:	2300      	movs	r3, #0
}
 800167a:	4618      	mov	r0, r3
 800167c:	46bd      	mov	sp, r7
 800167e:	bc80      	pop	{r7}
 8001680:	4770      	bx	lr

08001682 <LL_RCC_MSI_IsEnabledRangeSelect>:
{
 8001682:	b480      	push	{r7}
 8001684:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8001686:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800168a:	681b      	ldr	r3, [r3, #0]
 800168c:	f003 0308 	and.w	r3, r3, #8
 8001690:	2b08      	cmp	r3, #8
 8001692:	d101      	bne.n	8001698 <LL_RCC_MSI_IsEnabledRangeSelect+0x16>
 8001694:	2301      	movs	r3, #1
 8001696:	e000      	b.n	800169a <LL_RCC_MSI_IsEnabledRangeSelect+0x18>
 8001698:	2300      	movs	r3, #0
}
 800169a:	4618      	mov	r0, r3
 800169c:	46bd      	mov	sp, r7
 800169e:	bc80      	pop	{r7}
 80016a0:	4770      	bx	lr

080016a2 <LL_RCC_MSI_GetRange>:
{
 80016a2:	b480      	push	{r7}
 80016a4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 80016a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80016aa:	681b      	ldr	r3, [r3, #0]
 80016ac:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 80016b0:	4618      	mov	r0, r3
 80016b2:	46bd      	mov	sp, r7
 80016b4:	bc80      	pop	{r7}
 80016b6:	4770      	bx	lr

080016b8 <LL_RCC_MSI_GetRangeAfterStandby>:
{
 80016b8:	b480      	push	{r7}
 80016ba:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80016bc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80016c0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80016c4:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
}
 80016c8:	4618      	mov	r0, r3
 80016ca:	46bd      	mov	sp, r7
 80016cc:	bc80      	pop	{r7}
 80016ce:	4770      	bx	lr

080016d0 <LL_RCC_MSI_SetCalibTrimming>:
{
 80016d0:	b480      	push	{r7}
 80016d2:	b083      	sub	sp, #12
 80016d4:	af00      	add	r7, sp, #0
 80016d6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 80016d8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80016dc:	685b      	ldr	r3, [r3, #4]
 80016de:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 80016e2:	687b      	ldr	r3, [r7, #4]
 80016e4:	021b      	lsls	r3, r3, #8
 80016e6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80016ea:	4313      	orrs	r3, r2
 80016ec:	604b      	str	r3, [r1, #4]
}
 80016ee:	bf00      	nop
 80016f0:	370c      	adds	r7, #12
 80016f2:	46bd      	mov	sp, r7
 80016f4:	bc80      	pop	{r7}
 80016f6:	4770      	bx	lr

080016f8 <LL_RCC_SetSysClkSource>:
{
 80016f8:	b480      	push	{r7}
 80016fa:	b083      	sub	sp, #12
 80016fc:	af00      	add	r7, sp, #0
 80016fe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8001700:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001704:	689b      	ldr	r3, [r3, #8]
 8001706:	f023 0203 	bic.w	r2, r3, #3
 800170a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800170e:	687b      	ldr	r3, [r7, #4]
 8001710:	4313      	orrs	r3, r2
 8001712:	608b      	str	r3, [r1, #8]
}
 8001714:	bf00      	nop
 8001716:	370c      	adds	r7, #12
 8001718:	46bd      	mov	sp, r7
 800171a:	bc80      	pop	{r7}
 800171c:	4770      	bx	lr

0800171e <LL_RCC_GetSysClkSource>:
{
 800171e:	b480      	push	{r7}
 8001720:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8001722:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001726:	689b      	ldr	r3, [r3, #8]
 8001728:	f003 030c 	and.w	r3, r3, #12
}
 800172c:	4618      	mov	r0, r3
 800172e:	46bd      	mov	sp, r7
 8001730:	bc80      	pop	{r7}
 8001732:	4770      	bx	lr

08001734 <LL_RCC_SetAHBPrescaler>:
{
 8001734:	b480      	push	{r7}
 8001736:	b083      	sub	sp, #12
 8001738:	af00      	add	r7, sp, #0
 800173a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 800173c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001740:	689b      	ldr	r3, [r3, #8]
 8001742:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001746:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800174a:	687b      	ldr	r3, [r7, #4]
 800174c:	4313      	orrs	r3, r2
 800174e:	608b      	str	r3, [r1, #8]
}
 8001750:	bf00      	nop
 8001752:	370c      	adds	r7, #12
 8001754:	46bd      	mov	sp, r7
 8001756:	bc80      	pop	{r7}
 8001758:	4770      	bx	lr

0800175a <LL_RCC_SetAHB3Prescaler>:
{
 800175a:	b480      	push	{r7}
 800175c:	b083      	sub	sp, #12
 800175e:	af00      	add	r7, sp, #0
 8001760:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 8001762:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001766:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800176a:	f023 020f 	bic.w	r2, r3, #15
 800176e:	687b      	ldr	r3, [r7, #4]
 8001770:	091b      	lsrs	r3, r3, #4
 8001772:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001776:	4313      	orrs	r3, r2
 8001778:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 800177c:	bf00      	nop
 800177e:	370c      	adds	r7, #12
 8001780:	46bd      	mov	sp, r7
 8001782:	bc80      	pop	{r7}
 8001784:	4770      	bx	lr

08001786 <LL_RCC_SetAPB1Prescaler>:
{
 8001786:	b480      	push	{r7}
 8001788:	b083      	sub	sp, #12
 800178a:	af00      	add	r7, sp, #0
 800178c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800178e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001792:	689b      	ldr	r3, [r3, #8]
 8001794:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8001798:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800179c:	687b      	ldr	r3, [r7, #4]
 800179e:	4313      	orrs	r3, r2
 80017a0:	608b      	str	r3, [r1, #8]
}
 80017a2:	bf00      	nop
 80017a4:	370c      	adds	r7, #12
 80017a6:	46bd      	mov	sp, r7
 80017a8:	bc80      	pop	{r7}
 80017aa:	4770      	bx	lr

080017ac <LL_RCC_SetAPB2Prescaler>:
{
 80017ac:	b480      	push	{r7}
 80017ae:	b083      	sub	sp, #12
 80017b0:	af00      	add	r7, sp, #0
 80017b2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 80017b4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80017b8:	689b      	ldr	r3, [r3, #8]
 80017ba:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 80017be:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80017c2:	687b      	ldr	r3, [r7, #4]
 80017c4:	4313      	orrs	r3, r2
 80017c6:	608b      	str	r3, [r1, #8]
}
 80017c8:	bf00      	nop
 80017ca:	370c      	adds	r7, #12
 80017cc:	46bd      	mov	sp, r7
 80017ce:	bc80      	pop	{r7}
 80017d0:	4770      	bx	lr

080017d2 <LL_RCC_GetAHBPrescaler>:
{
 80017d2:	b480      	push	{r7}
 80017d4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80017d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80017da:	689b      	ldr	r3, [r3, #8]
 80017dc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 80017e0:	4618      	mov	r0, r3
 80017e2:	46bd      	mov	sp, r7
 80017e4:	bc80      	pop	{r7}
 80017e6:	4770      	bx	lr

080017e8 <LL_RCC_GetAHB3Prescaler>:
{
 80017e8:	b480      	push	{r7}
 80017ea:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 80017ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80017f0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80017f4:	011b      	lsls	r3, r3, #4
 80017f6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 80017fa:	4618      	mov	r0, r3
 80017fc:	46bd      	mov	sp, r7
 80017fe:	bc80      	pop	{r7}
 8001800:	4770      	bx	lr

08001802 <LL_RCC_PLL_Enable>:
  * @brief  Enable PLL
  * @rmtoll CR           PLLON         LL_RCC_PLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Enable(void)
{
 8001802:	b480      	push	{r7}
 8001804:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8001806:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800180a:	681b      	ldr	r3, [r3, #0]
 800180c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001810:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001814:	6013      	str	r3, [r2, #0]
}
 8001816:	bf00      	nop
 8001818:	46bd      	mov	sp, r7
 800181a:	bc80      	pop	{r7}
 800181c:	4770      	bx	lr

0800181e <LL_RCC_PLL_Disable>:
  * @note Cannot be disabled if the PLL clock is used as the system clock
  * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Disable(void)
{
 800181e:	b480      	push	{r7}
 8001820:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8001822:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001826:	681b      	ldr	r3, [r3, #0]
 8001828:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800182c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001830:	6013      	str	r3, [r2, #0]
}
 8001832:	bf00      	nop
 8001834:	46bd      	mov	sp, r7
 8001836:	bc80      	pop	{r7}
 8001838:	4770      	bx	lr

0800183a <LL_RCC_PLL_IsReady>:
  * @brief  Check if PLL Ready
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
 800183a:	b480      	push	{r7}
 800183c:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 800183e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001842:	681b      	ldr	r3, [r3, #0]
 8001844:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8001848:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800184c:	d101      	bne.n	8001852 <LL_RCC_PLL_IsReady+0x18>
 800184e:	2301      	movs	r3, #1
 8001850:	e000      	b.n	8001854 <LL_RCC_PLL_IsReady+0x1a>
 8001852:	2300      	movs	r3, #0
}
 8001854:	4618      	mov	r0, r3
 8001856:	46bd      	mov	sp, r7
 8001858:	bc80      	pop	{r7}
 800185a:	4770      	bx	lr

0800185c <LL_RCC_PLL_GetN>:
  * @brief  Get Main PLL multiplication factor for VCO
  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
  * @retval Between 6 and 127
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
{
 800185c:	b480      	push	{r7}
 800185e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8001860:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001864:	68db      	ldr	r3, [r3, #12]
 8001866:	0a1b      	lsrs	r3, r3, #8
 8001868:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 800186c:	4618      	mov	r0, r3
 800186e:	46bd      	mov	sp, r7
 8001870:	bc80      	pop	{r7}
 8001872:	4770      	bx	lr

08001874 <LL_RCC_PLL_GetR>:
  *         @arg @ref LL_RCC_PLLR_DIV_6
  *         @arg @ref LL_RCC_PLLR_DIV_7
  *         @arg @ref LL_RCC_PLLR_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
{
 8001874:	b480      	push	{r7}
 8001876:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8001878:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800187c:	68db      	ldr	r3, [r3, #12]
 800187e:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
}
 8001882:	4618      	mov	r0, r3
 8001884:	46bd      	mov	sp, r7
 8001886:	bc80      	pop	{r7}
 8001888:	4770      	bx	lr

0800188a <LL_RCC_PLL_GetDivider>:
  *         @arg @ref LL_RCC_PLLM_DIV_6
  *         @arg @ref LL_RCC_PLLM_DIV_7
  *         @arg @ref LL_RCC_PLLM_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
 800188a:	b480      	push	{r7}
 800188c:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 800188e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001892:	68db      	ldr	r3, [r3, #12]
 8001894:	f003 0370 	and.w	r3, r3, #112	; 0x70
}
 8001898:	4618      	mov	r0, r3
 800189a:	46bd      	mov	sp, r7
 800189c:	bc80      	pop	{r7}
 800189e:	4770      	bx	lr

080018a0 <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
 80018a0:	b480      	push	{r7}
 80018a2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80018a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80018a8:	68db      	ldr	r3, [r3, #12]
 80018aa:	f003 0303 	and.w	r3, r3, #3
}
 80018ae:	4618      	mov	r0, r3
 80018b0:	46bd      	mov	sp, r7
 80018b2:	bc80      	pop	{r7}
 80018b4:	4770      	bx	lr

080018b6 <LL_RCC_IsActiveFlag_HPRE>:
  * @brief  Check if HCLK1 prescaler flag value has been applied or not
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
 80018b6:	b480      	push	{r7}
 80018b8:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 80018ba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80018be:	689b      	ldr	r3, [r3, #8]
 80018c0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80018c4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80018c8:	d101      	bne.n	80018ce <LL_RCC_IsActiveFlag_HPRE+0x18>
 80018ca:	2301      	movs	r3, #1
 80018cc:	e000      	b.n	80018d0 <LL_RCC_IsActiveFlag_HPRE+0x1a>
 80018ce:	2300      	movs	r3, #0
}
 80018d0:	4618      	mov	r0, r3
 80018d2:	46bd      	mov	sp, r7
 80018d4:	bc80      	pop	{r7}
 80018d6:	4770      	bx	lr

080018d8 <LL_RCC_IsActiveFlag_SHDHPRE>:
  * @brief  Check if HCLK3 prescaler flag value has been applied or not
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
 80018d8:	b480      	push	{r7}
 80018da:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 80018dc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80018e0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80018e4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80018e8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80018ec:	d101      	bne.n	80018f2 <LL_RCC_IsActiveFlag_SHDHPRE+0x1a>
 80018ee:	2301      	movs	r3, #1
 80018f0:	e000      	b.n	80018f4 <LL_RCC_IsActiveFlag_SHDHPRE+0x1c>
 80018f2:	2300      	movs	r3, #0
}
 80018f4:	4618      	mov	r0, r3
 80018f6:	46bd      	mov	sp, r7
 80018f8:	bc80      	pop	{r7}
 80018fa:	4770      	bx	lr

080018fc <LL_RCC_IsActiveFlag_PPRE1>:
  * @brief  Check if PLCK1 prescaler flag value has been applied or not
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
 80018fc:	b480      	push	{r7}
 80018fe:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 8001900:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001904:	689b      	ldr	r3, [r3, #8]
 8001906:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800190a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800190e:	d101      	bne.n	8001914 <LL_RCC_IsActiveFlag_PPRE1+0x18>
 8001910:	2301      	movs	r3, #1
 8001912:	e000      	b.n	8001916 <LL_RCC_IsActiveFlag_PPRE1+0x1a>
 8001914:	2300      	movs	r3, #0
}
 8001916:	4618      	mov	r0, r3
 8001918:	46bd      	mov	sp, r7
 800191a:	bc80      	pop	{r7}
 800191c:	4770      	bx	lr

0800191e <LL_RCC_IsActiveFlag_PPRE2>:
  * @brief  Check if PLCK2 prescaler flag value has been applied or not
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
 800191e:	b480      	push	{r7}
 8001920:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 8001922:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001926:	689b      	ldr	r3, [r3, #8]
 8001928:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800192c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001930:	d101      	bne.n	8001936 <LL_RCC_IsActiveFlag_PPRE2+0x18>
 8001932:	2301      	movs	r3, #1
 8001934:	e000      	b.n	8001938 <LL_RCC_IsActiveFlag_PPRE2+0x1a>
 8001936:	2300      	movs	r3, #0
}
 8001938:	4618      	mov	r0, r3
 800193a:	46bd      	mov	sp, r7
 800193c:	bc80      	pop	{r7}
 800193e:	4770      	bx	lr

08001940 <HAL_RCC_OscConfig>:
  *         contains the configuration information for the RCC Oscillators.
  * @note   The PLL is not disabled when used as system clock.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001940:	b580      	push	{r7, lr}
 8001942:	b088      	sub	sp, #32
 8001944:	af00      	add	r7, sp, #0
 8001946:	6078      	str	r0, [r7, #4]
  uint32_t sysclk_source;
  uint32_t pll_config;
  HAL_StatusTypeDef status;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8001948:	687b      	ldr	r3, [r7, #4]
 800194a:	2b00      	cmp	r3, #0
 800194c:	d101      	bne.n	8001952 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800194e:	2301      	movs	r3, #1
 8001950:	e38b      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001952:	f7ff fee4 	bl	800171e <LL_RCC_GetSysClkSource>
 8001956:	61f8      	str	r0, [r7, #28]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001958:	f7ff ffa2 	bl	80018a0 <LL_RCC_PLL_GetMainSource>
 800195c:	61b8      	str	r0, [r7, #24]

  /*----------------------------- MSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800195e:	687b      	ldr	r3, [r7, #4]
 8001960:	681b      	ldr	r3, [r3, #0]
 8001962:	f003 0320 	and.w	r3, r3, #32
 8001966:	2b00      	cmp	r3, #0
 8001968:	f000 80c9 	beq.w	8001afe <HAL_RCC_OscConfig+0x1be>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSI_CALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800196c:	69fb      	ldr	r3, [r7, #28]
 800196e:	2b00      	cmp	r3, #0
 8001970:	d005      	beq.n	800197e <HAL_RCC_OscConfig+0x3e>
 8001972:	69fb      	ldr	r3, [r7, #28]
 8001974:	2b0c      	cmp	r3, #12
 8001976:	d17b      	bne.n	8001a70 <HAL_RCC_OscConfig+0x130>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 8001978:	69bb      	ldr	r3, [r7, #24]
 800197a:	2b01      	cmp	r3, #1
 800197c:	d178      	bne.n	8001a70 <HAL_RCC_OscConfig+0x130>
    {
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800197e:	f7ff fe70 	bl	8001662 <LL_RCC_MSI_IsReady>
 8001982:	4603      	mov	r3, r0
 8001984:	2b00      	cmp	r3, #0
 8001986:	d005      	beq.n	8001994 <HAL_RCC_OscConfig+0x54>
 8001988:	687b      	ldr	r3, [r7, #4]
 800198a:	6a1b      	ldr	r3, [r3, #32]
 800198c:	2b00      	cmp	r3, #0
 800198e:	d101      	bne.n	8001994 <HAL_RCC_OscConfig+0x54>
      {
        return HAL_ERROR;
 8001990:	2301      	movs	r3, #1
 8001992:	e36a      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the AHB3 clock
           and the supply voltage of the device. */
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8001994:	687b      	ldr	r3, [r7, #4]
 8001996:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001998:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800199c:	681b      	ldr	r3, [r3, #0]
 800199e:	f003 0308 	and.w	r3, r3, #8
 80019a2:	2b00      	cmp	r3, #0
 80019a4:	d005      	beq.n	80019b2 <HAL_RCC_OscConfig+0x72>
 80019a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019aa:	681b      	ldr	r3, [r3, #0]
 80019ac:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80019b0:	e006      	b.n	80019c0 <HAL_RCC_OscConfig+0x80>
 80019b2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019b6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80019ba:	091b      	lsrs	r3, r3, #4
 80019bc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80019c0:	4293      	cmp	r3, r2
 80019c2:	d222      	bcs.n	8001a0a <HAL_RCC_OscConfig+0xca>
        {
          /* First increase number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80019c4:	687b      	ldr	r3, [r7, #4]
 80019c6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80019c8:	4618      	mov	r0, r3
 80019ca:	f000 fd2d 	bl	8002428 <RCC_SetFlashLatencyFromMSIRange>
 80019ce:	4603      	mov	r3, r0
 80019d0:	2b00      	cmp	r3, #0
 80019d2:	d001      	beq.n	80019d8 <HAL_RCC_OscConfig+0x98>
          {
            return HAL_ERROR;
 80019d4:	2301      	movs	r3, #1
 80019d6:	e348      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80019d8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019dc:	681b      	ldr	r3, [r3, #0]
 80019de:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80019e2:	f043 0308 	orr.w	r3, r3, #8
 80019e6:	6013      	str	r3, [r2, #0]
 80019e8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019ec:	681b      	ldr	r3, [r3, #0]
 80019ee:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80019f2:	687b      	ldr	r3, [r7, #4]
 80019f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80019f6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80019fa:	4313      	orrs	r3, r2
 80019fc:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80019fe:	687b      	ldr	r3, [r7, #4]
 8001a00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001a02:	4618      	mov	r0, r3
 8001a04:	f7ff fe64 	bl	80016d0 <LL_RCC_MSI_SetCalibTrimming>
 8001a08:	e021      	b.n	8001a4e <HAL_RCC_OscConfig+0x10e>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8001a0a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001a0e:	681b      	ldr	r3, [r3, #0]
 8001a10:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001a14:	f043 0308 	orr.w	r3, r3, #8
 8001a18:	6013      	str	r3, [r2, #0]
 8001a1a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001a1e:	681b      	ldr	r3, [r3, #0]
 8001a20:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001a24:	687b      	ldr	r3, [r7, #4]
 8001a26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001a28:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001a2c:	4313      	orrs	r3, r2
 8001a2e:	600b      	str	r3, [r1, #0]
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001a30:	687b      	ldr	r3, [r7, #4]
 8001a32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001a34:	4618      	mov	r0, r3
 8001a36:	f7ff fe4b 	bl	80016d0 <LL_RCC_MSI_SetCalibTrimming>

          /* Decrease number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8001a3a:	687b      	ldr	r3, [r7, #4]
 8001a3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001a3e:	4618      	mov	r0, r3
 8001a40:	f000 fcf2 	bl	8002428 <RCC_SetFlashLatencyFromMSIRange>
 8001a44:	4603      	mov	r3, r0
 8001a46:	2b00      	cmp	r3, #0
 8001a48:	d001      	beq.n	8001a4e <HAL_RCC_OscConfig+0x10e>
          {
            return HAL_ERROR;
 8001a4a:	2301      	movs	r3, #1
 8001a4c:	e30d      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8001a4e:	f000 fcd7 	bl	8002400 <HAL_RCC_GetHCLKFreq>
 8001a52:	4603      	mov	r3, r0
 8001a54:	4aa1      	ldr	r2, [pc, #644]	; (8001cdc <HAL_RCC_OscConfig+0x39c>)
 8001a56:	6013      	str	r3, [r2, #0]

        /* Configure the source of time base considering new system clocks settings*/
        status = HAL_InitTick(uwTickPrio);
 8001a58:	4ba1      	ldr	r3, [pc, #644]	; (8001ce0 <HAL_RCC_OscConfig+0x3a0>)
 8001a5a:	681b      	ldr	r3, [r3, #0]
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	f7fe fd57 	bl	8000510 <HAL_InitTick>
 8001a62:	4603      	mov	r3, r0
 8001a64:	74fb      	strb	r3, [r7, #19]
        if (status != HAL_OK)
 8001a66:	7cfb      	ldrb	r3, [r7, #19]
 8001a68:	2b00      	cmp	r3, #0
 8001a6a:	d047      	beq.n	8001afc <HAL_RCC_OscConfig+0x1bc>
        {
          return status;
 8001a6c:	7cfb      	ldrb	r3, [r7, #19]
 8001a6e:	e2fc      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      }
    }
    else
    {
      /* Check the MSI State */
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8001a70:	687b      	ldr	r3, [r7, #4]
 8001a72:	6a1b      	ldr	r3, [r3, #32]
 8001a74:	2b00      	cmp	r3, #0
 8001a76:	d02c      	beq.n	8001ad2 <HAL_RCC_OscConfig+0x192>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8001a78:	f7ff fdd7 	bl	800162a <LL_RCC_MSI_Enable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 8001a7c:	f7fe fd94 	bl	80005a8 <HAL_GetTick>
 8001a80:	6178      	str	r0, [r7, #20]

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
 8001a82:	e008      	b.n	8001a96 <HAL_RCC_OscConfig+0x156>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8001a84:	f7fe fd90 	bl	80005a8 <HAL_GetTick>
 8001a88:	4602      	mov	r2, r0
 8001a8a:	697b      	ldr	r3, [r7, #20]
 8001a8c:	1ad3      	subs	r3, r2, r3
 8001a8e:	2b02      	cmp	r3, #2
 8001a90:	d901      	bls.n	8001a96 <HAL_RCC_OscConfig+0x156>
          {
            return HAL_TIMEOUT;
 8001a92:	2303      	movs	r3, #3
 8001a94:	e2e9      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_MSI_IsReady() == 0U)
 8001a96:	f7ff fde4 	bl	8001662 <LL_RCC_MSI_IsReady>
 8001a9a:	4603      	mov	r3, r0
 8001a9c:	2b00      	cmp	r3, #0
 8001a9e:	d0f1      	beq.n	8001a84 <HAL_RCC_OscConfig+0x144>
          }
        }

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8001aa0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001aa4:	681b      	ldr	r3, [r3, #0]
 8001aa6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001aaa:	f043 0308 	orr.w	r3, r3, #8
 8001aae:	6013      	str	r3, [r2, #0]
 8001ab0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001ab4:	681b      	ldr	r3, [r3, #0]
 8001ab6:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001aba:	687b      	ldr	r3, [r7, #4]
 8001abc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001abe:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001ac2:	4313      	orrs	r3, r2
 8001ac4:	600b      	str	r3, [r1, #0]
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8001ac6:	687b      	ldr	r3, [r7, #4]
 8001ac8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001aca:	4618      	mov	r0, r3
 8001acc:	f7ff fe00 	bl	80016d0 <LL_RCC_MSI_SetCalibTrimming>
 8001ad0:	e015      	b.n	8001afe <HAL_RCC_OscConfig+0x1be>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 8001ad2:	f7ff fdb8 	bl	8001646 <LL_RCC_MSI_Disable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 8001ad6:	f7fe fd67 	bl	80005a8 <HAL_GetTick>
 8001ada:	6178      	str	r0, [r7, #20]

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
 8001adc:	e008      	b.n	8001af0 <HAL_RCC_OscConfig+0x1b0>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8001ade:	f7fe fd63 	bl	80005a8 <HAL_GetTick>
 8001ae2:	4602      	mov	r2, r0
 8001ae4:	697b      	ldr	r3, [r7, #20]
 8001ae6:	1ad3      	subs	r3, r2, r3
 8001ae8:	2b02      	cmp	r3, #2
 8001aea:	d901      	bls.n	8001af0 <HAL_RCC_OscConfig+0x1b0>
          {
            return HAL_TIMEOUT;
 8001aec:	2303      	movs	r3, #3
 8001aee:	e2bc      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_MSI_IsReady() != 0U)
 8001af0:	f7ff fdb7 	bl	8001662 <LL_RCC_MSI_IsReady>
 8001af4:	4603      	mov	r3, r0
 8001af6:	2b00      	cmp	r3, #0
 8001af8:	d1f1      	bne.n	8001ade <HAL_RCC_OscConfig+0x19e>
 8001afa:	e000      	b.n	8001afe <HAL_RCC_OscConfig+0x1be>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8001afc:	bf00      	nop
      }
    }
  }

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001afe:	687b      	ldr	r3, [r7, #4]
 8001b00:	681b      	ldr	r3, [r3, #0]
 8001b02:	f003 0301 	and.w	r3, r3, #1
 8001b06:	2b00      	cmp	r3, #0
 8001b08:	d05f      	beq.n	8001bca <HAL_RCC_OscConfig+0x28a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 8001b0a:	69fb      	ldr	r3, [r7, #28]
 8001b0c:	2b08      	cmp	r3, #8
 8001b0e:	d005      	beq.n	8001b1c <HAL_RCC_OscConfig+0x1dc>
 8001b10:	69fb      	ldr	r3, [r7, #28]
 8001b12:	2b0c      	cmp	r3, #12
 8001b14:	d10d      	bne.n	8001b32 <HAL_RCC_OscConfig+0x1f2>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 8001b16:	69bb      	ldr	r3, [r7, #24]
 8001b18:	2b03      	cmp	r3, #3
 8001b1a:	d10a      	bne.n	8001b32 <HAL_RCC_OscConfig+0x1f2>
    {
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001b1c:	f7ff fcf1 	bl	8001502 <LL_RCC_HSE_IsReady>
 8001b20:	4603      	mov	r3, r0
 8001b22:	2b00      	cmp	r3, #0
 8001b24:	d050      	beq.n	8001bc8 <HAL_RCC_OscConfig+0x288>
 8001b26:	687b      	ldr	r3, [r7, #4]
 8001b28:	685b      	ldr	r3, [r3, #4]
 8001b2a:	2b00      	cmp	r3, #0
 8001b2c:	d14c      	bne.n	8001bc8 <HAL_RCC_OscConfig+0x288>
      {
        return HAL_ERROR;
 8001b2e:	2301      	movs	r3, #1
 8001b30:	e29b      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      /* Set the new HSE configuration ---------------------------------------*/
      /* Check HSE division factor */
      assert_param(IS_RCC_HSEDIV(RCC_OscInitStruct->HSEDiv));

      /* Set HSE division factor */
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 8001b32:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001b36:	681b      	ldr	r3, [r3, #0]
 8001b38:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 8001b3c:	687b      	ldr	r3, [r7, #4]
 8001b3e:	689b      	ldr	r3, [r3, #8]
 8001b40:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001b44:	4313      	orrs	r3, r2
 8001b46:	600b      	str	r3, [r1, #0]

      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001b48:	687b      	ldr	r3, [r7, #4]
 8001b4a:	685b      	ldr	r3, [r3, #4]
 8001b4c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001b50:	d102      	bne.n	8001b58 <HAL_RCC_OscConfig+0x218>
 8001b52:	f7ff fcba 	bl	80014ca <LL_RCC_HSE_Enable>
 8001b56:	e00d      	b.n	8001b74 <HAL_RCC_OscConfig+0x234>
 8001b58:	687b      	ldr	r3, [r7, #4]
 8001b5a:	685b      	ldr	r3, [r3, #4]
 8001b5c:	f5b3 1f04 	cmp.w	r3, #2162688	; 0x210000
 8001b60:	d104      	bne.n	8001b6c <HAL_RCC_OscConfig+0x22c>
 8001b62:	f7ff fc85 	bl	8001470 <LL_RCC_HSE_EnableTcxo>
 8001b66:	f7ff fcb0 	bl	80014ca <LL_RCC_HSE_Enable>
 8001b6a:	e003      	b.n	8001b74 <HAL_RCC_OscConfig+0x234>
 8001b6c:	f7ff fcbb 	bl	80014e6 <LL_RCC_HSE_Disable>
 8001b70:	f7ff fc8c 	bl	800148c <LL_RCC_HSE_DisableTcxo>

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001b74:	687b      	ldr	r3, [r7, #4]
 8001b76:	685b      	ldr	r3, [r3, #4]
 8001b78:	2b00      	cmp	r3, #0
 8001b7a:	d012      	beq.n	8001ba2 <HAL_RCC_OscConfig+0x262>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001b7c:	f7fe fd14 	bl	80005a8 <HAL_GetTick>
 8001b80:	6178      	str	r0, [r7, #20]

        /* Wait till HSE is ready */
        while (LL_RCC_HSE_IsReady() == 0U)
 8001b82:	e008      	b.n	8001b96 <HAL_RCC_OscConfig+0x256>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001b84:	f7fe fd10 	bl	80005a8 <HAL_GetTick>
 8001b88:	4602      	mov	r2, r0
 8001b8a:	697b      	ldr	r3, [r7, #20]
 8001b8c:	1ad3      	subs	r3, r2, r3
 8001b8e:	2b64      	cmp	r3, #100	; 0x64
 8001b90:	d901      	bls.n	8001b96 <HAL_RCC_OscConfig+0x256>
          {
            return HAL_TIMEOUT;
 8001b92:	2303      	movs	r3, #3
 8001b94:	e269      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_HSE_IsReady() == 0U)
 8001b96:	f7ff fcb4 	bl	8001502 <LL_RCC_HSE_IsReady>
 8001b9a:	4603      	mov	r3, r0
 8001b9c:	2b00      	cmp	r3, #0
 8001b9e:	d0f1      	beq.n	8001b84 <HAL_RCC_OscConfig+0x244>
 8001ba0:	e013      	b.n	8001bca <HAL_RCC_OscConfig+0x28a>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001ba2:	f7fe fd01 	bl	80005a8 <HAL_GetTick>
 8001ba6:	6178      	str	r0, [r7, #20]

        /* Wait till HSE is disabled */
        while (LL_RCC_HSE_IsReady() != 0U)
 8001ba8:	e008      	b.n	8001bbc <HAL_RCC_OscConfig+0x27c>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001baa:	f7fe fcfd 	bl	80005a8 <HAL_GetTick>
 8001bae:	4602      	mov	r2, r0
 8001bb0:	697b      	ldr	r3, [r7, #20]
 8001bb2:	1ad3      	subs	r3, r2, r3
 8001bb4:	2b64      	cmp	r3, #100	; 0x64
 8001bb6:	d901      	bls.n	8001bbc <HAL_RCC_OscConfig+0x27c>
          {
            return HAL_TIMEOUT;
 8001bb8:	2303      	movs	r3, #3
 8001bba:	e256      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_HSE_IsReady() != 0U)
 8001bbc:	f7ff fca1 	bl	8001502 <LL_RCC_HSE_IsReady>
 8001bc0:	4603      	mov	r3, r0
 8001bc2:	2b00      	cmp	r3, #0
 8001bc4:	d1f1      	bne.n	8001baa <HAL_RCC_OscConfig+0x26a>
 8001bc6:	e000      	b.n	8001bca <HAL_RCC_OscConfig+0x28a>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001bc8:	bf00      	nop
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001bca:	687b      	ldr	r3, [r7, #4]
 8001bcc:	681b      	ldr	r3, [r3, #0]
 8001bce:	f003 0302 	and.w	r3, r3, #2
 8001bd2:	2b00      	cmp	r3, #0
 8001bd4:	d04b      	beq.n	8001c6e <HAL_RCC_OscConfig+0x32e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8001bd6:	69fb      	ldr	r3, [r7, #28]
 8001bd8:	2b04      	cmp	r3, #4
 8001bda:	d005      	beq.n	8001be8 <HAL_RCC_OscConfig+0x2a8>
 8001bdc:	69fb      	ldr	r3, [r7, #28]
 8001bde:	2b0c      	cmp	r3, #12
 8001be0:	d113      	bne.n	8001c0a <HAL_RCC_OscConfig+0x2ca>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 8001be2:	69bb      	ldr	r3, [r7, #24]
 8001be4:	2b02      	cmp	r3, #2
 8001be6:	d110      	bne.n	8001c0a <HAL_RCC_OscConfig+0x2ca>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8001be8:	f7ff fcb8 	bl	800155c <LL_RCC_HSI_IsReady>
 8001bec:	4603      	mov	r3, r0
 8001bee:	2b00      	cmp	r3, #0
 8001bf0:	d005      	beq.n	8001bfe <HAL_RCC_OscConfig+0x2be>
 8001bf2:	687b      	ldr	r3, [r7, #4]
 8001bf4:	691b      	ldr	r3, [r3, #16]
 8001bf6:	2b00      	cmp	r3, #0
 8001bf8:	d101      	bne.n	8001bfe <HAL_RCC_OscConfig+0x2be>
      {
        return HAL_ERROR;
 8001bfa:	2301      	movs	r3, #1
 8001bfc:	e235      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001bfe:	687b      	ldr	r3, [r7, #4]
 8001c00:	695b      	ldr	r3, [r3, #20]
 8001c02:	4618      	mov	r0, r3
 8001c04:	f7ff fcbb 	bl	800157e <LL_RCC_HSI_SetCalibTrimming>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8001c08:	e031      	b.n	8001c6e <HAL_RCC_OscConfig+0x32e>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001c0a:	687b      	ldr	r3, [r7, #4]
 8001c0c:	691b      	ldr	r3, [r3, #16]
 8001c0e:	2b00      	cmp	r3, #0
 8001c10:	d019      	beq.n	8001c46 <HAL_RCC_OscConfig+0x306>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001c12:	f7ff fc87 	bl	8001524 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001c16:	f7fe fcc7 	bl	80005a8 <HAL_GetTick>
 8001c1a:	6178      	str	r0, [r7, #20]

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
 8001c1c:	e008      	b.n	8001c30 <HAL_RCC_OscConfig+0x2f0>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001c1e:	f7fe fcc3 	bl	80005a8 <HAL_GetTick>
 8001c22:	4602      	mov	r2, r0
 8001c24:	697b      	ldr	r3, [r7, #20]
 8001c26:	1ad3      	subs	r3, r2, r3
 8001c28:	2b02      	cmp	r3, #2
 8001c2a:	d901      	bls.n	8001c30 <HAL_RCC_OscConfig+0x2f0>
          {
            return HAL_TIMEOUT;
 8001c2c:	2303      	movs	r3, #3
 8001c2e:	e21c      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_HSI_IsReady() == 0U)
 8001c30:	f7ff fc94 	bl	800155c <LL_RCC_HSI_IsReady>
 8001c34:	4603      	mov	r3, r0
 8001c36:	2b00      	cmp	r3, #0
 8001c38:	d0f1      	beq.n	8001c1e <HAL_RCC_OscConfig+0x2de>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001c3a:	687b      	ldr	r3, [r7, #4]
 8001c3c:	695b      	ldr	r3, [r3, #20]
 8001c3e:	4618      	mov	r0, r3
 8001c40:	f7ff fc9d 	bl	800157e <LL_RCC_HSI_SetCalibTrimming>
 8001c44:	e013      	b.n	8001c6e <HAL_RCC_OscConfig+0x32e>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001c46:	f7ff fc7b 	bl	8001540 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001c4a:	f7fe fcad 	bl	80005a8 <HAL_GetTick>
 8001c4e:	6178      	str	r0, [r7, #20]

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
 8001c50:	e008      	b.n	8001c64 <HAL_RCC_OscConfig+0x324>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001c52:	f7fe fca9 	bl	80005a8 <HAL_GetTick>
 8001c56:	4602      	mov	r2, r0
 8001c58:	697b      	ldr	r3, [r7, #20]
 8001c5a:	1ad3      	subs	r3, r2, r3
 8001c5c:	2b02      	cmp	r3, #2
 8001c5e:	d901      	bls.n	8001c64 <HAL_RCC_OscConfig+0x324>
          {
            return HAL_TIMEOUT;
 8001c60:	2303      	movs	r3, #3
 8001c62:	e202      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_HSI_IsReady() != 0U)
 8001c64:	f7ff fc7a 	bl	800155c <LL_RCC_HSI_IsReady>
 8001c68:	4603      	mov	r3, r0
 8001c6a:	2b00      	cmp	r3, #0
 8001c6c:	d1f1      	bne.n	8001c52 <HAL_RCC_OscConfig+0x312>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001c6e:	687b      	ldr	r3, [r7, #4]
 8001c70:	681b      	ldr	r3, [r3, #0]
 8001c72:	f003 0308 	and.w	r3, r3, #8
 8001c76:	2b00      	cmp	r3, #0
 8001c78:	d06f      	beq.n	8001d5a <HAL_RCC_OscConfig+0x41a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001c7a:	687b      	ldr	r3, [r7, #4]
 8001c7c:	699b      	ldr	r3, [r3, #24]
 8001c7e:	2b00      	cmp	r3, #0
 8001c80:	d057      	beq.n	8001d32 <HAL_RCC_OscConfig+0x3f2>
    {
      uint32_t csr_temp = RCC->CSR;
 8001c82:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001c86:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8001c8a:	60fb      	str	r3, [r7, #12]

      /* Check LSI division factor */
      assert_param(IS_RCC_LSIDIV(RCC_OscInitStruct->LSIDiv));

      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 8001c8c:	687b      	ldr	r3, [r7, #4]
 8001c8e:	69da      	ldr	r2, [r3, #28]
 8001c90:	68fb      	ldr	r3, [r7, #12]
 8001c92:	f003 0310 	and.w	r3, r3, #16
 8001c96:	429a      	cmp	r2, r3
 8001c98:	d036      	beq.n	8001d08 <HAL_RCC_OscConfig+0x3c8>
      {
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 8001c9a:	68fb      	ldr	r3, [r7, #12]
 8001c9c:	f003 0302 	and.w	r3, r3, #2
 8001ca0:	2b00      	cmp	r3, #0
 8001ca2:	d006      	beq.n	8001cb2 <HAL_RCC_OscConfig+0x372>
            ((csr_temp & RCC_CSR_LSION) != RCC_CSR_LSION))
 8001ca4:	68fb      	ldr	r3, [r7, #12]
 8001ca6:	f003 0301 	and.w	r3, r3, #1
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 8001caa:	2b00      	cmp	r3, #0
 8001cac:	d101      	bne.n	8001cb2 <HAL_RCC_OscConfig+0x372>
        {
          /* If LSIRDY is set while LSION is not enabled,
             LSIPRE can't be updated  */
          return HAL_ERROR;
 8001cae:	2301      	movs	r3, #1
 8001cb0:	e1db      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        }

        /* Turn off LSI before changing RCC_CSR_LSIPRE */
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 8001cb2:	68fb      	ldr	r3, [r7, #12]
 8001cb4:	f003 0301 	and.w	r3, r3, #1
 8001cb8:	2b00      	cmp	r3, #0
 8001cba:	d018      	beq.n	8001cee <HAL_RCC_OscConfig+0x3ae>
        {
          __HAL_RCC_LSI_DISABLE();
 8001cbc:	f7ff fc94 	bl	80015e8 <LL_RCC_LSI_Disable>

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8001cc0:	f7fe fc72 	bl	80005a8 <HAL_GetTick>
 8001cc4:	6178      	str	r0, [r7, #20]

          /* Wait till LSI is disabled */
          while (LL_RCC_LSI_IsReady() != 0U)
 8001cc6:	e00d      	b.n	8001ce4 <HAL_RCC_OscConfig+0x3a4>
          {
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001cc8:	f7fe fc6e 	bl	80005a8 <HAL_GetTick>
 8001ccc:	4602      	mov	r2, r0
 8001cce:	697b      	ldr	r3, [r7, #20]
 8001cd0:	1ad3      	subs	r3, r2, r3
 8001cd2:	2b11      	cmp	r3, #17
 8001cd4:	d906      	bls.n	8001ce4 <HAL_RCC_OscConfig+0x3a4>
            {
              return HAL_TIMEOUT;
 8001cd6:	2303      	movs	r3, #3
 8001cd8:	e1c7      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
 8001cda:	bf00      	nop
 8001cdc:	20000000 	.word	0x20000000
 8001ce0:	20000004 	.word	0x20000004
          while (LL_RCC_LSI_IsReady() != 0U)
 8001ce4:	f7ff fc90 	bl	8001608 <LL_RCC_LSI_IsReady>
 8001ce8:	4603      	mov	r3, r0
 8001cea:	2b00      	cmp	r3, #0
 8001cec:	d1ec      	bne.n	8001cc8 <HAL_RCC_OscConfig+0x388>
            }
          }
        }

        /* Set LSI division factor */
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 8001cee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001cf2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8001cf6:	f023 0210 	bic.w	r2, r3, #16
 8001cfa:	687b      	ldr	r3, [r7, #4]
 8001cfc:	69db      	ldr	r3, [r3, #28]
 8001cfe:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001d02:	4313      	orrs	r3, r2
 8001d04:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
      }

      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001d08:	f7ff fc5e 	bl	80015c8 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d0c:	f7fe fc4c 	bl	80005a8 <HAL_GetTick>
 8001d10:	6178      	str	r0, [r7, #20]

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
 8001d12:	e008      	b.n	8001d26 <HAL_RCC_OscConfig+0x3e6>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001d14:	f7fe fc48 	bl	80005a8 <HAL_GetTick>
 8001d18:	4602      	mov	r2, r0
 8001d1a:	697b      	ldr	r3, [r7, #20]
 8001d1c:	1ad3      	subs	r3, r2, r3
 8001d1e:	2b11      	cmp	r3, #17
 8001d20:	d901      	bls.n	8001d26 <HAL_RCC_OscConfig+0x3e6>
        {
          return HAL_TIMEOUT;
 8001d22:	2303      	movs	r3, #3
 8001d24:	e1a1      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      while (LL_RCC_LSI_IsReady() == 0U)
 8001d26:	f7ff fc6f 	bl	8001608 <LL_RCC_LSI_IsReady>
 8001d2a:	4603      	mov	r3, r0
 8001d2c:	2b00      	cmp	r3, #0
 8001d2e:	d0f1      	beq.n	8001d14 <HAL_RCC_OscConfig+0x3d4>
 8001d30:	e013      	b.n	8001d5a <HAL_RCC_OscConfig+0x41a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001d32:	f7ff fc59 	bl	80015e8 <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d36:	f7fe fc37 	bl	80005a8 <HAL_GetTick>
 8001d3a:	6178      	str	r0, [r7, #20]

      /* Wait till LSI is disabled */
      while (LL_RCC_LSI_IsReady() != 0U)
 8001d3c:	e008      	b.n	8001d50 <HAL_RCC_OscConfig+0x410>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001d3e:	f7fe fc33 	bl	80005a8 <HAL_GetTick>
 8001d42:	4602      	mov	r2, r0
 8001d44:	697b      	ldr	r3, [r7, #20]
 8001d46:	1ad3      	subs	r3, r2, r3
 8001d48:	2b11      	cmp	r3, #17
 8001d4a:	d901      	bls.n	8001d50 <HAL_RCC_OscConfig+0x410>
        {
          return HAL_TIMEOUT;
 8001d4c:	2303      	movs	r3, #3
 8001d4e:	e18c      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      while (LL_RCC_LSI_IsReady() != 0U)
 8001d50:	f7ff fc5a 	bl	8001608 <LL_RCC_LSI_IsReady>
 8001d54:	4603      	mov	r3, r0
 8001d56:	2b00      	cmp	r3, #0
 8001d58:	d1f1      	bne.n	8001d3e <HAL_RCC_OscConfig+0x3fe>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	681b      	ldr	r3, [r3, #0]
 8001d5e:	f003 0304 	and.w	r3, r3, #4
 8001d62:	2b00      	cmp	r3, #0
 8001d64:	f000 80d8 	beq.w	8001f18 <HAL_RCC_OscConfig+0x5d8>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */

    if (LL_PWR_IsEnabledBkUpAccess() == 0U)
 8001d68:	f7ff fb70 	bl	800144c <LL_PWR_IsEnabledBkUpAccess>
 8001d6c:	4603      	mov	r3, r0
 8001d6e:	2b00      	cmp	r3, #0
 8001d70:	d113      	bne.n	8001d9a <HAL_RCC_OscConfig+0x45a>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 8001d72:	f7ff fb27 	bl	80013c4 <HAL_PWR_EnableBkUpAccess>

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8001d76:	f7fe fc17 	bl	80005a8 <HAL_GetTick>
 8001d7a:	6178      	str	r0, [r7, #20]

      while (LL_PWR_IsEnabledBkUpAccess() == 0U)
 8001d7c:	e008      	b.n	8001d90 <HAL_RCC_OscConfig+0x450>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001d7e:	f7fe fc13 	bl	80005a8 <HAL_GetTick>
 8001d82:	4602      	mov	r2, r0
 8001d84:	697b      	ldr	r3, [r7, #20]
 8001d86:	1ad3      	subs	r3, r2, r3
 8001d88:	2b02      	cmp	r3, #2
 8001d8a:	d901      	bls.n	8001d90 <HAL_RCC_OscConfig+0x450>
        {
          return HAL_TIMEOUT;
 8001d8c:	2303      	movs	r3, #3
 8001d8e:	e16c      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      while (LL_PWR_IsEnabledBkUpAccess() == 0U)
 8001d90:	f7ff fb5c 	bl	800144c <LL_PWR_IsEnabledBkUpAccess>
 8001d94:	4603      	mov	r3, r0
 8001d96:	2b00      	cmp	r3, #0
 8001d98:	d0f1      	beq.n	8001d7e <HAL_RCC_OscConfig+0x43e>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8001d9a:	687b      	ldr	r3, [r7, #4]
 8001d9c:	68db      	ldr	r3, [r3, #12]
 8001d9e:	2b00      	cmp	r3, #0
 8001da0:	d07b      	beq.n	8001e9a <HAL_RCC_OscConfig+0x55a>
    {
      /* Enable LSE bypasss (if requested) */
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS)
 8001da2:	687b      	ldr	r3, [r7, #4]
 8001da4:	68db      	ldr	r3, [r3, #12]
 8001da6:	2b85      	cmp	r3, #133	; 0x85
 8001da8:	d003      	beq.n	8001db2 <HAL_RCC_OscConfig+0x472>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 8001daa:	687b      	ldr	r3, [r7, #4]
 8001dac:	68db      	ldr	r3, [r3, #12]
 8001dae:	2b05      	cmp	r3, #5
 8001db0:	d109      	bne.n	8001dc6 <HAL_RCC_OscConfig+0x486>
      {
        /* LSE oscillator bypass enable */
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8001db2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001db6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001dba:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001dbe:	f043 0304 	orr.w	r3, r3, #4
 8001dc2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001dc6:	f7fe fbef 	bl	80005a8 <HAL_GetTick>
 8001dca:	6178      	str	r0, [r7, #20]

      /* LSE oscillator enable */
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8001dcc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001dd0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001dd4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001dd8:	f043 0301 	orr.w	r3, r3, #1
 8001ddc:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
 8001de0:	e00a      	b.n	8001df8 <HAL_RCC_OscConfig+0x4b8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001de2:	f7fe fbe1 	bl	80005a8 <HAL_GetTick>
 8001de6:	4602      	mov	r2, r0
 8001de8:	697b      	ldr	r3, [r7, #20]
 8001dea:	1ad3      	subs	r3, r2, r3
 8001dec:	f241 3288 	movw	r2, #5000	; 0x1388
 8001df0:	4293      	cmp	r3, r2
 8001df2:	d901      	bls.n	8001df8 <HAL_RCC_OscConfig+0x4b8>
        {
          return HAL_TIMEOUT;
 8001df4:	2303      	movs	r3, #3
 8001df6:	e138      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      while (LL_RCC_LSE_IsReady() == 0U)
 8001df8:	f7ff fbd5 	bl	80015a6 <LL_RCC_LSE_IsReady>
 8001dfc:	4603      	mov	r3, r0
 8001dfe:	2b00      	cmp	r3, #0
 8001e00:	d0ef      	beq.n	8001de2 <HAL_RCC_OscConfig+0x4a2>
        }
      }

      /* Enable LSE system clock (if requested) */
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 8001e02:	687b      	ldr	r3, [r7, #4]
 8001e04:	68db      	ldr	r3, [r3, #12]
 8001e06:	2b81      	cmp	r3, #129	; 0x81
 8001e08:	d003      	beq.n	8001e12 <HAL_RCC_OscConfig+0x4d2>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS))
 8001e0a:	687b      	ldr	r3, [r7, #4]
 8001e0c:	68db      	ldr	r3, [r3, #12]
 8001e0e:	2b85      	cmp	r3, #133	; 0x85
 8001e10:	d121      	bne.n	8001e56 <HAL_RCC_OscConfig+0x516>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001e12:	f7fe fbc9 	bl	80005a8 <HAL_GetTick>
 8001e16:	6178      	str	r0, [r7, #20]

        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8001e18:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001e1c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001e20:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001e24:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001e28:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

        /* Wait till LSESYS is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8001e2c:	e00a      	b.n	8001e44 <HAL_RCC_OscConfig+0x504>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001e2e:	f7fe fbbb 	bl	80005a8 <HAL_GetTick>
 8001e32:	4602      	mov	r2, r0
 8001e34:	697b      	ldr	r3, [r7, #20]
 8001e36:	1ad3      	subs	r3, r2, r3
 8001e38:	f241 3288 	movw	r2, #5000	; 0x1388
 8001e3c:	4293      	cmp	r3, r2
 8001e3e:	d901      	bls.n	8001e44 <HAL_RCC_OscConfig+0x504>
          {
            return HAL_TIMEOUT;
 8001e40:	2303      	movs	r3, #3
 8001e42:	e112      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 8001e44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001e48:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001e4c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001e50:	2b00      	cmp	r3, #0
 8001e52:	d0ec      	beq.n	8001e2e <HAL_RCC_OscConfig+0x4ee>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 8001e54:	e060      	b.n	8001f18 <HAL_RCC_OscConfig+0x5d8>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001e56:	f7fe fba7 	bl	80005a8 <HAL_GetTick>
 8001e5a:	6178      	str	r0, [r7, #20]

        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8001e5c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001e60:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001e64:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001e68:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001e6c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

        /* Wait till LSESYSRDY is cleared */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8001e70:	e00a      	b.n	8001e88 <HAL_RCC_OscConfig+0x548>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001e72:	f7fe fb99 	bl	80005a8 <HAL_GetTick>
 8001e76:	4602      	mov	r2, r0
 8001e78:	697b      	ldr	r3, [r7, #20]
 8001e7a:	1ad3      	subs	r3, r2, r3
 8001e7c:	f241 3288 	movw	r2, #5000	; 0x1388
 8001e80:	4293      	cmp	r3, r2
 8001e82:	d901      	bls.n	8001e88 <HAL_RCC_OscConfig+0x548>
          {
            return HAL_TIMEOUT;
 8001e84:	2303      	movs	r3, #3
 8001e86:	e0f0      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8001e88:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001e8c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001e90:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001e94:	2b00      	cmp	r3, #0
 8001e96:	d1ec      	bne.n	8001e72 <HAL_RCC_OscConfig+0x532>
 8001e98:	e03e      	b.n	8001f18 <HAL_RCC_OscConfig+0x5d8>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001e9a:	f7fe fb85 	bl	80005a8 <HAL_GetTick>
 8001e9e:	6178      	str	r0, [r7, #20]

      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8001ea0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001ea4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001ea8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001eac:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001eb0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

      /* Wait till LSESYSRDY is cleared */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8001eb4:	e00a      	b.n	8001ecc <HAL_RCC_OscConfig+0x58c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001eb6:	f7fe fb77 	bl	80005a8 <HAL_GetTick>
 8001eba:	4602      	mov	r2, r0
 8001ebc:	697b      	ldr	r3, [r7, #20]
 8001ebe:	1ad3      	subs	r3, r2, r3
 8001ec0:	f241 3288 	movw	r2, #5000	; 0x1388
 8001ec4:	4293      	cmp	r3, r2
 8001ec6:	d901      	bls.n	8001ecc <HAL_RCC_OscConfig+0x58c>
        {
          return HAL_TIMEOUT;
 8001ec8:	2303      	movs	r3, #3
 8001eca:	e0ce      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8001ecc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001ed0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001ed4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001ed8:	2b00      	cmp	r3, #0
 8001eda:	d1ec      	bne.n	8001eb6 <HAL_RCC_OscConfig+0x576>
        }
      }

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001edc:	f7fe fb64 	bl	80005a8 <HAL_GetTick>
 8001ee0:	6178      	str	r0, [r7, #20]

      /* LSE oscillator disable */
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8001ee2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001ee6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001eea:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001eee:	f023 0301 	bic.w	r3, r3, #1
 8001ef2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
 8001ef6:	e00a      	b.n	8001f0e <HAL_RCC_OscConfig+0x5ce>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001ef8:	f7fe fb56 	bl	80005a8 <HAL_GetTick>
 8001efc:	4602      	mov	r2, r0
 8001efe:	697b      	ldr	r3, [r7, #20]
 8001f00:	1ad3      	subs	r3, r2, r3
 8001f02:	f241 3288 	movw	r2, #5000	; 0x1388
 8001f06:	4293      	cmp	r3, r2
 8001f08:	d901      	bls.n	8001f0e <HAL_RCC_OscConfig+0x5ce>
        {
          return HAL_TIMEOUT;
 8001f0a:	2303      	movs	r3, #3
 8001f0c:	e0ad      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      while (LL_RCC_LSE_IsReady() != 0U)
 8001f0e:	f7ff fb4a 	bl	80015a6 <LL_RCC_LSE_IsReady>
 8001f12:	4603      	mov	r3, r0
 8001f14:	2b00      	cmp	r3, #0
 8001f16:	d1ef      	bne.n	8001ef8 <HAL_RCC_OscConfig+0x5b8>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8001f18:	687b      	ldr	r3, [r7, #4]
 8001f1a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001f1c:	2b00      	cmp	r3, #0
 8001f1e:	f000 80a3 	beq.w	8002068 <HAL_RCC_OscConfig+0x728>
  {
    /* Check if the PLL is used as system clock or not */
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001f22:	69fb      	ldr	r3, [r7, #28]
 8001f24:	2b0c      	cmp	r3, #12
 8001f26:	d076      	beq.n	8002016 <HAL_RCC_OscConfig+0x6d6>
    {
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001f28:	687b      	ldr	r3, [r7, #4]
 8001f2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001f2c:	2b02      	cmp	r3, #2
 8001f2e:	d14b      	bne.n	8001fc8 <HAL_RCC_OscConfig+0x688>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001f30:	f7ff fc75 	bl	800181e <LL_RCC_PLL_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001f34:	f7fe fb38 	bl	80005a8 <HAL_GetTick>
 8001f38:	6178      	str	r0, [r7, #20]

        /* Wait till PLL is ready */
        while (LL_RCC_PLL_IsReady() != 0U)
 8001f3a:	e008      	b.n	8001f4e <HAL_RCC_OscConfig+0x60e>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001f3c:	f7fe fb34 	bl	80005a8 <HAL_GetTick>
 8001f40:	4602      	mov	r2, r0
 8001f42:	697b      	ldr	r3, [r7, #20]
 8001f44:	1ad3      	subs	r3, r2, r3
 8001f46:	2b0a      	cmp	r3, #10
 8001f48:	d901      	bls.n	8001f4e <HAL_RCC_OscConfig+0x60e>
          {
            return HAL_TIMEOUT;
 8001f4a:	2303      	movs	r3, #3
 8001f4c:	e08d      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_PLL_IsReady() != 0U)
 8001f4e:	f7ff fc74 	bl	800183a <LL_RCC_PLL_IsReady>
 8001f52:	4603      	mov	r3, r0
 8001f54:	2b00      	cmp	r3, #0
 8001f56:	d1f1      	bne.n	8001f3c <HAL_RCC_OscConfig+0x5fc>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001f58:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001f5c:	68da      	ldr	r2, [r3, #12]
 8001f5e:	4b45      	ldr	r3, [pc, #276]	; (8002074 <HAL_RCC_OscConfig+0x734>)
 8001f60:	4013      	ands	r3, r2
 8001f62:	687a      	ldr	r2, [r7, #4]
 8001f64:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8001f66:	687a      	ldr	r2, [r7, #4]
 8001f68:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8001f6a:	4311      	orrs	r1, r2
 8001f6c:	687a      	ldr	r2, [r7, #4]
 8001f6e:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8001f70:	0212      	lsls	r2, r2, #8
 8001f72:	4311      	orrs	r1, r2
 8001f74:	687a      	ldr	r2, [r7, #4]
 8001f76:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8001f78:	4311      	orrs	r1, r2
 8001f7a:	687a      	ldr	r2, [r7, #4]
 8001f7c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8001f7e:	4311      	orrs	r1, r2
 8001f80:	687a      	ldr	r2, [r7, #4]
 8001f82:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8001f84:	430a      	orrs	r2, r1
 8001f86:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001f8a:	4313      	orrs	r3, r2
 8001f8c:	60cb      	str	r3, [r1, #12]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8001f8e:	f7ff fc38 	bl	8001802 <LL_RCC_PLL_Enable>

        /* Enable PLL System Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001f92:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001f96:	68db      	ldr	r3, [r3, #12]
 8001f98:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001f9c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001fa0:	60d3      	str	r3, [r2, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001fa2:	f7fe fb01 	bl	80005a8 <HAL_GetTick>
 8001fa6:	6178      	str	r0, [r7, #20]

        /* Wait till PLL is ready */
        while (LL_RCC_PLL_IsReady() == 0U)
 8001fa8:	e008      	b.n	8001fbc <HAL_RCC_OscConfig+0x67c>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001faa:	f7fe fafd 	bl	80005a8 <HAL_GetTick>
 8001fae:	4602      	mov	r2, r0
 8001fb0:	697b      	ldr	r3, [r7, #20]
 8001fb2:	1ad3      	subs	r3, r2, r3
 8001fb4:	2b0a      	cmp	r3, #10
 8001fb6:	d901      	bls.n	8001fbc <HAL_RCC_OscConfig+0x67c>
          {
            return HAL_TIMEOUT;
 8001fb8:	2303      	movs	r3, #3
 8001fba:	e056      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_PLL_IsReady() == 0U)
 8001fbc:	f7ff fc3d 	bl	800183a <LL_RCC_PLL_IsReady>
 8001fc0:	4603      	mov	r3, r0
 8001fc2:	2b00      	cmp	r3, #0
 8001fc4:	d0f1      	beq.n	8001faa <HAL_RCC_OscConfig+0x66a>
 8001fc6:	e04f      	b.n	8002068 <HAL_RCC_OscConfig+0x728>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001fc8:	f7ff fc29 	bl	800181e <LL_RCC_PLL_Disable>

        /* Disable all PLL outputs to save power */
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8001fcc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001fd0:	68db      	ldr	r3, [r3, #12]
 8001fd2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001fd6:	f023 0303 	bic.w	r3, r3, #3
 8001fda:	60d3      	str	r3, [r2, #12]

        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 8001fdc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001fe0:	68db      	ldr	r3, [r3, #12]
 8001fe2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001fe6:	f023 5388 	bic.w	r3, r3, #285212672	; 0x11000000
 8001fea:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001fee:	60d3      	str	r3, [r2, #12]


        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001ff0:	f7fe fada 	bl	80005a8 <HAL_GetTick>
 8001ff4:	6178      	str	r0, [r7, #20]

        /* Wait till PLL is disabled */
        while (LL_RCC_PLL_IsReady() != 0U)
 8001ff6:	e008      	b.n	800200a <HAL_RCC_OscConfig+0x6ca>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001ff8:	f7fe fad6 	bl	80005a8 <HAL_GetTick>
 8001ffc:	4602      	mov	r2, r0
 8001ffe:	697b      	ldr	r3, [r7, #20]
 8002000:	1ad3      	subs	r3, r2, r3
 8002002:	2b0a      	cmp	r3, #10
 8002004:	d901      	bls.n	800200a <HAL_RCC_OscConfig+0x6ca>
          {
            return HAL_TIMEOUT;
 8002006:	2303      	movs	r3, #3
 8002008:	e02f      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        while (LL_RCC_PLL_IsReady() != 0U)
 800200a:	f7ff fc16 	bl	800183a <LL_RCC_PLL_IsReady>
 800200e:	4603      	mov	r3, r0
 8002010:	2b00      	cmp	r3, #0
 8002012:	d1f1      	bne.n	8001ff8 <HAL_RCC_OscConfig+0x6b8>
 8002014:	e028      	b.n	8002068 <HAL_RCC_OscConfig+0x728>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8002016:	687b      	ldr	r3, [r7, #4]
 8002018:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800201a:	2b01      	cmp	r3, #1
 800201c:	d101      	bne.n	8002022 <HAL_RCC_OscConfig+0x6e2>
      {
        return HAL_ERROR;
 800201e:	2301      	movs	r3, #1
 8002020:	e023      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 8002022:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002026:	68db      	ldr	r3, [r3, #12]
 8002028:	61bb      	str	r3, [r7, #24]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 800202a:	69bb      	ldr	r3, [r7, #24]
 800202c:	f003 0203 	and.w	r2, r3, #3
 8002030:	687b      	ldr	r3, [r7, #4]
 8002032:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002034:	429a      	cmp	r2, r3
 8002036:	d115      	bne.n	8002064 <HAL_RCC_OscConfig+0x724>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 8002038:	69bb      	ldr	r3, [r7, #24]
 800203a:	f003 0270 	and.w	r2, r3, #112	; 0x70
 800203e:	687b      	ldr	r3, [r7, #4]
 8002040:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002042:	429a      	cmp	r2, r3
 8002044:	d10e      	bne.n	8002064 <HAL_RCC_OscConfig+0x724>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 8002046:	69bb      	ldr	r3, [r7, #24]
 8002048:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 800204c:	687b      	ldr	r3, [r7, #4]
 800204e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002050:	021b      	lsls	r3, r3, #8
 8002052:	429a      	cmp	r2, r3
 8002054:	d106      	bne.n	8002064 <HAL_RCC_OscConfig+0x724>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 8002056:	69bb      	ldr	r3, [r7, #24]
 8002058:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800205c:	687b      	ldr	r3, [r7, #4]
 800205e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002060:	429a      	cmp	r2, r3
 8002062:	d001      	beq.n	8002068 <HAL_RCC_OscConfig+0x728>
        {
          return HAL_ERROR;
 8002064:	2301      	movs	r3, #1
 8002066:	e000      	b.n	800206a <HAL_RCC_OscConfig+0x72a>
        }
      }
    }
  }
  return HAL_OK;
 8002068:	2300      	movs	r3, #0
}
 800206a:	4618      	mov	r0, r3
 800206c:	3720      	adds	r7, #32
 800206e:	46bd      	mov	sp, r7
 8002070:	bd80      	pop	{r7, pc}
 8002072:	bf00      	nop
 8002074:	11c1808c 	.word	0x11c1808c

08002078 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK1 not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8002078:	b580      	push	{r7, lr}
 800207a:	b084      	sub	sp, #16
 800207c:	af00      	add	r7, sp, #0
 800207e:	6078      	str	r0, [r7, #4]
 8002080:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8002082:	687b      	ldr	r3, [r7, #4]
 8002084:	2b00      	cmp	r3, #0
 8002086:	d101      	bne.n	800208c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8002088:	2301      	movs	r3, #1
 800208a:	e10f      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the FLASH clock
    (HCLK3) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800208c:	4b89      	ldr	r3, [pc, #548]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 800208e:	681b      	ldr	r3, [r3, #0]
 8002090:	f003 0307 	and.w	r3, r3, #7
 8002094:	683a      	ldr	r2, [r7, #0]
 8002096:	429a      	cmp	r2, r3
 8002098:	d91b      	bls.n	80020d2 <HAL_RCC_ClockConfig+0x5a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800209a:	4b86      	ldr	r3, [pc, #536]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 800209c:	681b      	ldr	r3, [r3, #0]
 800209e:	f023 0207 	bic.w	r2, r3, #7
 80020a2:	4984      	ldr	r1, [pc, #528]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 80020a4:	683b      	ldr	r3, [r7, #0]
 80020a6:	4313      	orrs	r3, r2
 80020a8:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80020aa:	f7fe fa7d 	bl	80005a8 <HAL_GetTick>
 80020ae:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80020b0:	e008      	b.n	80020c4 <HAL_RCC_ClockConfig+0x4c>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 80020b2:	f7fe fa79 	bl	80005a8 <HAL_GetTick>
 80020b6:	4602      	mov	r2, r0
 80020b8:	68fb      	ldr	r3, [r7, #12]
 80020ba:	1ad3      	subs	r3, r2, r3
 80020bc:	2b02      	cmp	r3, #2
 80020be:	d901      	bls.n	80020c4 <HAL_RCC_ClockConfig+0x4c>
      {
        return HAL_TIMEOUT;
 80020c0:	2303      	movs	r3, #3
 80020c2:	e0f3      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80020c4:	4b7b      	ldr	r3, [pc, #492]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 80020c6:	681b      	ldr	r3, [r3, #0]
 80020c8:	f003 0307 	and.w	r3, r3, #7
 80020cc:	683a      	ldr	r2, [r7, #0]
 80020ce:	429a      	cmp	r2, r3
 80020d0:	d1ef      	bne.n	80020b2 <HAL_RCC_ClockConfig+0x3a>
      }
    }
  }

  /*-------------------------- HCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80020d2:	687b      	ldr	r3, [r7, #4]
 80020d4:	681b      	ldr	r3, [r3, #0]
 80020d6:	f003 0302 	and.w	r3, r3, #2
 80020da:	2b00      	cmp	r3, #0
 80020dc:	d016      	beq.n	800210c <HAL_RCC_ClockConfig+0x94>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLKDivider));
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 80020de:	687b      	ldr	r3, [r7, #4]
 80020e0:	689b      	ldr	r3, [r3, #8]
 80020e2:	4618      	mov	r0, r3
 80020e4:	f7ff fb26 	bl	8001734 <LL_RCC_SetAHBPrescaler>

    /* HCLK1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 80020e8:	f7fe fa5e 	bl	80005a8 <HAL_GetTick>
 80020ec:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 80020ee:	e008      	b.n	8002102 <HAL_RCC_ClockConfig+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80020f0:	f7fe fa5a 	bl	80005a8 <HAL_GetTick>
 80020f4:	4602      	mov	r2, r0
 80020f6:	68fb      	ldr	r3, [r7, #12]
 80020f8:	1ad3      	subs	r3, r2, r3
 80020fa:	2b02      	cmp	r3, #2
 80020fc:	d901      	bls.n	8002102 <HAL_RCC_ClockConfig+0x8a>
      {
        return HAL_TIMEOUT;
 80020fe:	2303      	movs	r3, #3
 8002100:	e0d4      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 8002102:	f7ff fbd8 	bl	80018b6 <LL_RCC_IsActiveFlag_HPRE>
 8002106:	4603      	mov	r3, r0
 8002108:	2b00      	cmp	r3, #0
 800210a:	d0f1      	beq.n	80020f0 <HAL_RCC_ClockConfig+0x78>
    }
  }
#endif /* DUAL_CORE */

  /*-------------------------- HCLK3 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 800210c:	687b      	ldr	r3, [r7, #4]
 800210e:	681b      	ldr	r3, [r3, #0]
 8002110:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002114:	2b00      	cmp	r3, #0
 8002116:	d016      	beq.n	8002146 <HAL_RCC_ClockConfig+0xce>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK3Divider));
    LL_RCC_SetAHB3Prescaler(RCC_ClkInitStruct->AHBCLK3Divider);
 8002118:	687b      	ldr	r3, [r7, #4]
 800211a:	695b      	ldr	r3, [r3, #20]
 800211c:	4618      	mov	r0, r3
 800211e:	f7ff fb1c 	bl	800175a <LL_RCC_SetAHB3Prescaler>

    /* AHB shared prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8002122:	f7fe fa41 	bl	80005a8 <HAL_GetTick>
 8002126:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 8002128:	e008      	b.n	800213c <HAL_RCC_ClockConfig+0xc4>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800212a:	f7fe fa3d 	bl	80005a8 <HAL_GetTick>
 800212e:	4602      	mov	r2, r0
 8002130:	68fb      	ldr	r3, [r7, #12]
 8002132:	1ad3      	subs	r3, r2, r3
 8002134:	2b02      	cmp	r3, #2
 8002136:	d901      	bls.n	800213c <HAL_RCC_ClockConfig+0xc4>
      {
        return HAL_TIMEOUT;
 8002138:	2303      	movs	r3, #3
 800213a:	e0b7      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 800213c:	f7ff fbcc 	bl	80018d8 <LL_RCC_IsActiveFlag_SHDHPRE>
 8002140:	4603      	mov	r3, r0
 8002142:	2b00      	cmp	r3, #0
 8002144:	d0f1      	beq.n	800212a <HAL_RCC_ClockConfig+0xb2>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002146:	687b      	ldr	r3, [r7, #4]
 8002148:	681b      	ldr	r3, [r3, #0]
 800214a:	f003 0304 	and.w	r3, r3, #4
 800214e:	2b00      	cmp	r3, #0
 8002150:	d016      	beq.n	8002180 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB1CLKDivider));
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 8002152:	687b      	ldr	r3, [r7, #4]
 8002154:	68db      	ldr	r3, [r3, #12]
 8002156:	4618      	mov	r0, r3
 8002158:	f7ff fb15 	bl	8001786 <LL_RCC_SetAPB1Prescaler>

    /* APB1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 800215c:	f7fe fa24 	bl	80005a8 <HAL_GetTick>
 8002160:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8002162:	e008      	b.n	8002176 <HAL_RCC_ClockConfig+0xfe>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8002164:	f7fe fa20 	bl	80005a8 <HAL_GetTick>
 8002168:	4602      	mov	r2, r0
 800216a:	68fb      	ldr	r3, [r7, #12]
 800216c:	1ad3      	subs	r3, r2, r3
 800216e:	2b02      	cmp	r3, #2
 8002170:	d901      	bls.n	8002176 <HAL_RCC_ClockConfig+0xfe>
      {
        return HAL_TIMEOUT;
 8002172:	2303      	movs	r3, #3
 8002174:	e09a      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8002176:	f7ff fbc1 	bl	80018fc <LL_RCC_IsActiveFlag_PPRE1>
 800217a:	4603      	mov	r3, r0
 800217c:	2b00      	cmp	r3, #0
 800217e:	d0f1      	beq.n	8002164 <HAL_RCC_ClockConfig+0xec>
      }
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002180:	687b      	ldr	r3, [r7, #4]
 8002182:	681b      	ldr	r3, [r3, #0]
 8002184:	f003 0308 	and.w	r3, r3, #8
 8002188:	2b00      	cmp	r3, #0
 800218a:	d017      	beq.n	80021bc <HAL_RCC_ClockConfig+0x144>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB2CLKDivider));
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 800218c:	687b      	ldr	r3, [r7, #4]
 800218e:	691b      	ldr	r3, [r3, #16]
 8002190:	00db      	lsls	r3, r3, #3
 8002192:	4618      	mov	r0, r3
 8002194:	f7ff fb0a 	bl	80017ac <LL_RCC_SetAPB2Prescaler>

    /* APB2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8002198:	f7fe fa06 	bl	80005a8 <HAL_GetTick>
 800219c:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 800219e:	e008      	b.n	80021b2 <HAL_RCC_ClockConfig+0x13a>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80021a0:	f7fe fa02 	bl	80005a8 <HAL_GetTick>
 80021a4:	4602      	mov	r2, r0
 80021a6:	68fb      	ldr	r3, [r7, #12]
 80021a8:	1ad3      	subs	r3, r2, r3
 80021aa:	2b02      	cmp	r3, #2
 80021ac:	d901      	bls.n	80021b2 <HAL_RCC_ClockConfig+0x13a>
      {
        return HAL_TIMEOUT;
 80021ae:	2303      	movs	r3, #3
 80021b0:	e07c      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 80021b2:	f7ff fbb4 	bl	800191e <LL_RCC_IsActiveFlag_PPRE2>
 80021b6:	4603      	mov	r3, r0
 80021b8:	2b00      	cmp	r3, #0
 80021ba:	d0f1      	beq.n	80021a0 <HAL_RCC_ClockConfig+0x128>
      }
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80021bc:	687b      	ldr	r3, [r7, #4]
 80021be:	681b      	ldr	r3, [r3, #0]
 80021c0:	f003 0301 	and.w	r3, r3, #1
 80021c4:	2b00      	cmp	r3, #0
 80021c6:	d043      	beq.n	8002250 <HAL_RCC_ClockConfig+0x1d8>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80021c8:	687b      	ldr	r3, [r7, #4]
 80021ca:	685b      	ldr	r3, [r3, #4]
 80021cc:	2b02      	cmp	r3, #2
 80021ce:	d106      	bne.n	80021de <HAL_RCC_ClockConfig+0x166>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
 80021d0:	f7ff f997 	bl	8001502 <LL_RCC_HSE_IsReady>
 80021d4:	4603      	mov	r3, r0
 80021d6:	2b00      	cmp	r3, #0
 80021d8:	d11e      	bne.n	8002218 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 80021da:	2301      	movs	r3, #1
 80021dc:	e066      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80021de:	687b      	ldr	r3, [r7, #4]
 80021e0:	685b      	ldr	r3, [r3, #4]
 80021e2:	2b03      	cmp	r3, #3
 80021e4:	d106      	bne.n	80021f4 <HAL_RCC_ClockConfig+0x17c>
    {
      /* Check the PLL ready flag */
      if (LL_RCC_PLL_IsReady() == 0U)
 80021e6:	f7ff fb28 	bl	800183a <LL_RCC_PLL_IsReady>
 80021ea:	4603      	mov	r3, r0
 80021ec:	2b00      	cmp	r3, #0
 80021ee:	d113      	bne.n	8002218 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 80021f0:	2301      	movs	r3, #1
 80021f2:	e05b      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
      }
    }
    /* MSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80021f4:	687b      	ldr	r3, [r7, #4]
 80021f6:	685b      	ldr	r3, [r3, #4]
 80021f8:	2b00      	cmp	r3, #0
 80021fa:	d106      	bne.n	800220a <HAL_RCC_ClockConfig+0x192>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
 80021fc:	f7ff fa31 	bl	8001662 <LL_RCC_MSI_IsReady>
 8002200:	4603      	mov	r3, r0
 8002202:	2b00      	cmp	r3, #0
 8002204:	d108      	bne.n	8002218 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 8002206:	2301      	movs	r3, #1
 8002208:	e050      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
 800220a:	f7ff f9a7 	bl	800155c <LL_RCC_HSI_IsReady>
 800220e:	4603      	mov	r3, r0
 8002210:	2b00      	cmp	r3, #0
 8002212:	d101      	bne.n	8002218 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 8002214:	2301      	movs	r3, #1
 8002216:	e049      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
      }

    }

    /* apply system clock switch */
    LL_RCC_SetSysClkSource(RCC_ClkInitStruct->SYSCLKSource);
 8002218:	687b      	ldr	r3, [r7, #4]
 800221a:	685b      	ldr	r3, [r3, #4]
 800221c:	4618      	mov	r0, r3
 800221e:	f7ff fa6b 	bl	80016f8 <LL_RCC_SetSysClkSource>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8002222:	f7fe f9c1 	bl	80005a8 <HAL_GetTick>
 8002226:	60f8      	str	r0, [r7, #12]

    /* check system clock source switch status */
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002228:	e00a      	b.n	8002240 <HAL_RCC_ClockConfig+0x1c8>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800222a:	f7fe f9bd 	bl	80005a8 <HAL_GetTick>
 800222e:	4602      	mov	r2, r0
 8002230:	68fb      	ldr	r3, [r7, #12]
 8002232:	1ad3      	subs	r3, r2, r3
 8002234:	f241 3288 	movw	r2, #5000	; 0x1388
 8002238:	4293      	cmp	r3, r2
 800223a:	d901      	bls.n	8002240 <HAL_RCC_ClockConfig+0x1c8>
      {
        return HAL_TIMEOUT;
 800223c:	2303      	movs	r3, #3
 800223e:	e035      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002240:	f7ff fa6d 	bl	800171e <LL_RCC_GetSysClkSource>
 8002244:	4602      	mov	r2, r0
 8002246:	687b      	ldr	r3, [r7, #4]
 8002248:	685b      	ldr	r3, [r3, #4]
 800224a:	009b      	lsls	r3, r3, #2
 800224c:	429a      	cmp	r2, r3
 800224e:	d1ec      	bne.n	800222a <HAL_RCC_ClockConfig+0x1b2>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8002250:	4b18      	ldr	r3, [pc, #96]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 8002252:	681b      	ldr	r3, [r3, #0]
 8002254:	f003 0307 	and.w	r3, r3, #7
 8002258:	683a      	ldr	r2, [r7, #0]
 800225a:	429a      	cmp	r2, r3
 800225c:	d21b      	bcs.n	8002296 <HAL_RCC_ClockConfig+0x21e>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800225e:	4b15      	ldr	r3, [pc, #84]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 8002260:	681b      	ldr	r3, [r3, #0]
 8002262:	f023 0207 	bic.w	r2, r3, #7
 8002266:	4913      	ldr	r1, [pc, #76]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 8002268:	683b      	ldr	r3, [r7, #0]
 800226a:	4313      	orrs	r3, r2
 800226c:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800226e:	f7fe f99b 	bl	80005a8 <HAL_GetTick>
 8002272:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002274:	e008      	b.n	8002288 <HAL_RCC_ClockConfig+0x210>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8002276:	f7fe f997 	bl	80005a8 <HAL_GetTick>
 800227a:	4602      	mov	r2, r0
 800227c:	68fb      	ldr	r3, [r7, #12]
 800227e:	1ad3      	subs	r3, r2, r3
 8002280:	2b02      	cmp	r3, #2
 8002282:	d901      	bls.n	8002288 <HAL_RCC_ClockConfig+0x210>
      {
        return HAL_TIMEOUT;
 8002284:	2303      	movs	r3, #3
 8002286:	e011      	b.n	80022ac <HAL_RCC_ClockConfig+0x234>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002288:	4b0a      	ldr	r3, [pc, #40]	; (80022b4 <HAL_RCC_ClockConfig+0x23c>)
 800228a:	681b      	ldr	r3, [r3, #0]
 800228c:	f003 0307 	and.w	r3, r3, #7
 8002290:	683a      	ldr	r2, [r7, #0]
 8002292:	429a      	cmp	r2, r3
 8002294:	d1ef      	bne.n	8002276 <HAL_RCC_ClockConfig+0x1fe>
  }

  /*--------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8002296:	f000 f8b3 	bl	8002400 <HAL_RCC_GetHCLKFreq>
 800229a:	4603      	mov	r3, r0
 800229c:	4a06      	ldr	r2, [pc, #24]	; (80022b8 <HAL_RCC_ClockConfig+0x240>)
 800229e:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
 80022a0:	4b06      	ldr	r3, [pc, #24]	; (80022bc <HAL_RCC_ClockConfig+0x244>)
 80022a2:	681b      	ldr	r3, [r3, #0]
 80022a4:	4618      	mov	r0, r3
 80022a6:	f7fe f933 	bl	8000510 <HAL_InitTick>
 80022aa:	4603      	mov	r3, r0
}
 80022ac:	4618      	mov	r0, r3
 80022ae:	3710      	adds	r7, #16
 80022b0:	46bd      	mov	sp, r7
 80022b2:	bd80      	pop	{r7, pc}
 80022b4:	58004000 	.word	0x58004000
 80022b8:	20000000 	.word	0x20000000
 80022bc:	20000004 	.word	0x20000004

080022c0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80022c0:	b590      	push	{r4, r7, lr}
 80022c2:	b087      	sub	sp, #28
 80022c4:	af00      	add	r7, sp, #0
  uint32_t sysclk_source;
  uint32_t pllsource;
  uint32_t sysclockfreq = 0U;
 80022c6:	2300      	movs	r3, #0
 80022c8:	617b      	str	r3, [r7, #20]
  uint32_t msifreq = 0U;
 80022ca:	2300      	movs	r3, #0
 80022cc:	613b      	str	r3, [r7, #16]
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80022ce:	f7ff fa26 	bl	800171e <LL_RCC_GetSysClkSource>
 80022d2:	60b8      	str	r0, [r7, #8]
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 80022d4:	f7ff fae4 	bl	80018a0 <LL_RCC_PLL_GetMainSource>
 80022d8:	6078      	str	r0, [r7, #4]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80022da:	68bb      	ldr	r3, [r7, #8]
 80022dc:	2b00      	cmp	r3, #0
 80022de:	d005      	beq.n	80022ec <HAL_RCC_GetSysClockFreq+0x2c>
 80022e0:	68bb      	ldr	r3, [r7, #8]
 80022e2:	2b0c      	cmp	r3, #12
 80022e4:	d139      	bne.n	800235a <HAL_RCC_GetSysClockFreq+0x9a>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 80022e6:	687b      	ldr	r3, [r7, #4]
 80022e8:	2b01      	cmp	r3, #1
 80022ea:	d136      	bne.n	800235a <HAL_RCC_GetSysClockFreq+0x9a>
  {
    /* MSI or PLL with MSI source used as system clock source */
    /*Retrieve MSI frequency range in HZ*/
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 80022ec:	f7ff f9c9 	bl	8001682 <LL_RCC_MSI_IsEnabledRangeSelect>
 80022f0:	4603      	mov	r3, r0
 80022f2:	2b00      	cmp	r3, #0
 80022f4:	d115      	bne.n	8002322 <HAL_RCC_GetSysClockFreq+0x62>
 80022f6:	f7ff f9c4 	bl	8001682 <LL_RCC_MSI_IsEnabledRangeSelect>
 80022fa:	4603      	mov	r3, r0
 80022fc:	2b01      	cmp	r3, #1
 80022fe:	d106      	bne.n	800230e <HAL_RCC_GetSysClockFreq+0x4e>
 8002300:	f7ff f9cf 	bl	80016a2 <LL_RCC_MSI_GetRange>
 8002304:	4603      	mov	r3, r0
 8002306:	0a1b      	lsrs	r3, r3, #8
 8002308:	f003 030f 	and.w	r3, r3, #15
 800230c:	e005      	b.n	800231a <HAL_RCC_GetSysClockFreq+0x5a>
 800230e:	f7ff f9d3 	bl	80016b8 <LL_RCC_MSI_GetRangeAfterStandby>
 8002312:	4603      	mov	r3, r0
 8002314:	0a1b      	lsrs	r3, r3, #8
 8002316:	f003 030f 	and.w	r3, r3, #15
 800231a:	4a36      	ldr	r2, [pc, #216]	; (80023f4 <HAL_RCC_GetSysClockFreq+0x134>)
 800231c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002320:	e014      	b.n	800234c <HAL_RCC_GetSysClockFreq+0x8c>
 8002322:	f7ff f9ae 	bl	8001682 <LL_RCC_MSI_IsEnabledRangeSelect>
 8002326:	4603      	mov	r3, r0
 8002328:	2b01      	cmp	r3, #1
 800232a:	d106      	bne.n	800233a <HAL_RCC_GetSysClockFreq+0x7a>
 800232c:	f7ff f9b9 	bl	80016a2 <LL_RCC_MSI_GetRange>
 8002330:	4603      	mov	r3, r0
 8002332:	091b      	lsrs	r3, r3, #4
 8002334:	f003 030f 	and.w	r3, r3, #15
 8002338:	e005      	b.n	8002346 <HAL_RCC_GetSysClockFreq+0x86>
 800233a:	f7ff f9bd 	bl	80016b8 <LL_RCC_MSI_GetRangeAfterStandby>
 800233e:	4603      	mov	r3, r0
 8002340:	091b      	lsrs	r3, r3, #4
 8002342:	f003 030f 	and.w	r3, r3, #15
 8002346:	4a2b      	ldr	r2, [pc, #172]	; (80023f4 <HAL_RCC_GetSysClockFreq+0x134>)
 8002348:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800234c:	613b      	str	r3, [r7, #16]
                                     ((LL_RCC_MSI_IsEnabledRangeSelect() == 1U) ?
                                      LL_RCC_MSI_GetRange() :
                                      LL_RCC_MSI_GetRangeAfterStandby()));

    /* Get SYSCLK source */
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 800234e:	68bb      	ldr	r3, [r7, #8]
 8002350:	2b00      	cmp	r3, #0
 8002352:	d115      	bne.n	8002380 <HAL_RCC_GetSysClockFreq+0xc0>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
 8002354:	693b      	ldr	r3, [r7, #16]
 8002356:	617b      	str	r3, [r7, #20]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8002358:	e012      	b.n	8002380 <HAL_RCC_GetSysClockFreq+0xc0>
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 800235a:	68bb      	ldr	r3, [r7, #8]
 800235c:	2b04      	cmp	r3, #4
 800235e:	d102      	bne.n	8002366 <HAL_RCC_GetSysClockFreq+0xa6>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8002360:	4b25      	ldr	r3, [pc, #148]	; (80023f8 <HAL_RCC_GetSysClockFreq+0x138>)
 8002362:	617b      	str	r3, [r7, #20]
 8002364:	e00c      	b.n	8002380 <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8002366:	68bb      	ldr	r3, [r7, #8]
 8002368:	2b08      	cmp	r3, #8
 800236a:	d109      	bne.n	8002380 <HAL_RCC_GetSysClockFreq+0xc0>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 800236c:	f7ff f89c 	bl	80014a8 <LL_RCC_HSE_IsEnabledDiv2>
 8002370:	4603      	mov	r3, r0
 8002372:	2b01      	cmp	r3, #1
 8002374:	d102      	bne.n	800237c <HAL_RCC_GetSysClockFreq+0xbc>
    {
      sysclockfreq = HSE_VALUE / 2U;
 8002376:	4b20      	ldr	r3, [pc, #128]	; (80023f8 <HAL_RCC_GetSysClockFreq+0x138>)
 8002378:	617b      	str	r3, [r7, #20]
 800237a:	e001      	b.n	8002380 <HAL_RCC_GetSysClockFreq+0xc0>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 800237c:	4b1f      	ldr	r3, [pc, #124]	; (80023fc <HAL_RCC_GetSysClockFreq+0x13c>)
 800237e:	617b      	str	r3, [r7, #20]
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002380:	f7ff f9cd 	bl	800171e <LL_RCC_GetSysClkSource>
 8002384:	4603      	mov	r3, r0
 8002386:	2b0c      	cmp	r3, #12
 8002388:	d12f      	bne.n	80023ea <HAL_RCC_GetSysClockFreq+0x12a>
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 800238a:	f7ff fa89 	bl	80018a0 <LL_RCC_PLL_GetMainSource>
 800238e:	6078      	str	r0, [r7, #4]

    switch (pllsource)
 8002390:	687b      	ldr	r3, [r7, #4]
 8002392:	2b02      	cmp	r3, #2
 8002394:	d003      	beq.n	800239e <HAL_RCC_GetSysClockFreq+0xde>
 8002396:	687b      	ldr	r3, [r7, #4]
 8002398:	2b03      	cmp	r3, #3
 800239a:	d003      	beq.n	80023a4 <HAL_RCC_GetSysClockFreq+0xe4>
 800239c:	e00d      	b.n	80023ba <HAL_RCC_GetSysClockFreq+0xfa>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 800239e:	4b16      	ldr	r3, [pc, #88]	; (80023f8 <HAL_RCC_GetSysClockFreq+0x138>)
 80023a0:	60fb      	str	r3, [r7, #12]
        break;
 80023a2:	e00d      	b.n	80023c0 <HAL_RCC_GetSysClockFreq+0x100>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 80023a4:	f7ff f880 	bl	80014a8 <LL_RCC_HSE_IsEnabledDiv2>
 80023a8:	4603      	mov	r3, r0
 80023aa:	2b01      	cmp	r3, #1
 80023ac:	d102      	bne.n	80023b4 <HAL_RCC_GetSysClockFreq+0xf4>
        {
          pllinputfreq = HSE_VALUE / 2U;
 80023ae:	4b12      	ldr	r3, [pc, #72]	; (80023f8 <HAL_RCC_GetSysClockFreq+0x138>)
 80023b0:	60fb      	str	r3, [r7, #12]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 80023b2:	e005      	b.n	80023c0 <HAL_RCC_GetSysClockFreq+0x100>
          pllinputfreq = HSE_VALUE;
 80023b4:	4b11      	ldr	r3, [pc, #68]	; (80023fc <HAL_RCC_GetSysClockFreq+0x13c>)
 80023b6:	60fb      	str	r3, [r7, #12]
        break;
 80023b8:	e002      	b.n	80023c0 <HAL_RCC_GetSysClockFreq+0x100>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = msifreq;
 80023ba:	693b      	ldr	r3, [r7, #16]
 80023bc:	60fb      	str	r3, [r7, #12]
        break;
 80023be:	bf00      	nop
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80023c0:	f7ff fa4c 	bl	800185c <LL_RCC_PLL_GetN>
 80023c4:	4602      	mov	r2, r0
 80023c6:	68fb      	ldr	r3, [r7, #12]
 80023c8:	fb03 f402 	mul.w	r4, r3, r2
 80023cc:	f7ff fa5d 	bl	800188a <LL_RCC_PLL_GetDivider>
 80023d0:	4603      	mov	r3, r0
 80023d2:	091b      	lsrs	r3, r3, #4
 80023d4:	3301      	adds	r3, #1
 80023d6:	fbb4 f4f3 	udiv	r4, r4, r3
 80023da:	f7ff fa4b 	bl	8001874 <LL_RCC_PLL_GetR>
 80023de:	4603      	mov	r3, r0
 80023e0:	0f5b      	lsrs	r3, r3, #29
 80023e2:	3301      	adds	r3, #1
 80023e4:	fbb4 f3f3 	udiv	r3, r4, r3
 80023e8:	617b      	str	r3, [r7, #20]
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
 80023ea:	697b      	ldr	r3, [r7, #20]
}
 80023ec:	4618      	mov	r0, r3
 80023ee:	371c      	adds	r7, #28
 80023f0:	46bd      	mov	sp, r7
 80023f2:	bd90      	pop	{r4, r7, pc}
 80023f4:	08002a74 	.word	0x08002a74
 80023f8:	00f42400 	.word	0x00f42400
 80023fc:	01e84800 	.word	0x01e84800

08002400 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8002400:	b598      	push	{r3, r4, r7, lr}
 8002402:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK1 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8002404:	f7ff ff5c 	bl	80022c0 <HAL_RCC_GetSysClockFreq>
 8002408:	4604      	mov	r4, r0
 800240a:	f7ff f9e2 	bl	80017d2 <LL_RCC_GetAHBPrescaler>
 800240e:	4603      	mov	r3, r0
 8002410:	091b      	lsrs	r3, r3, #4
 8002412:	f003 030f 	and.w	r3, r3, #15
 8002416:	4a03      	ldr	r2, [pc, #12]	; (8002424 <HAL_RCC_GetHCLKFreq+0x24>)
 8002418:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800241c:	fbb4 f3f3 	udiv	r3, r4, r3
}
 8002420:	4618      	mov	r0, r3
 8002422:	bd98      	pop	{r3, r4, r7, pc}
 8002424:	08002a34 	.word	0x08002a34

08002428 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 8002428:	b590      	push	{r4, r7, lr}
 800242a:	b085      	sub	sp, #20
 800242c:	af00      	add	r7, sp, #0
 800242e:	6078      	str	r0, [r7, #4]
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 8002430:	687b      	ldr	r3, [r7, #4]
 8002432:	091b      	lsrs	r3, r3, #4
 8002434:	f003 030f 	and.w	r3, r3, #15
 8002438:	4a10      	ldr	r2, [pc, #64]	; (800247c <RCC_SetFlashLatencyFromMSIRange+0x54>)
 800243a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800243e:	60fb      	str	r3, [r7, #12]
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 8002440:	f7ff f9d2 	bl	80017e8 <LL_RCC_GetAHB3Prescaler>
 8002444:	4603      	mov	r3, r0
 8002446:	091b      	lsrs	r3, r3, #4
 8002448:	f003 030f 	and.w	r3, r3, #15
 800244c:	4a0c      	ldr	r2, [pc, #48]	; (8002480 <RCC_SetFlashLatencyFromMSIRange+0x58>)
 800244e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002452:	68fa      	ldr	r2, [r7, #12]
 8002454:	fbb2 f3f3 	udiv	r3, r2, r3
 8002458:	60bb      	str	r3, [r7, #8]

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 800245a:	68bb      	ldr	r3, [r7, #8]
 800245c:	4a09      	ldr	r2, [pc, #36]	; (8002484 <RCC_SetFlashLatencyFromMSIRange+0x5c>)
 800245e:	fba2 2303 	umull	r2, r3, r2, r3
 8002462:	0c9c      	lsrs	r4, r3, #18
 8002464:	f7fe ffbc 	bl	80013e0 <HAL_PWREx_GetVoltageRange>
 8002468:	4603      	mov	r3, r0
 800246a:	4619      	mov	r1, r3
 800246c:	4620      	mov	r0, r4
 800246e:	f000 f80b 	bl	8002488 <RCC_SetFlashLatency>
 8002472:	4603      	mov	r3, r0
}
 8002474:	4618      	mov	r0, r3
 8002476:	3714      	adds	r7, #20
 8002478:	46bd      	mov	sp, r7
 800247a:	bd90      	pop	{r4, r7, pc}
 800247c:	08002a74 	.word	0x08002a74
 8002480:	08002a34 	.word	0x08002a34
 8002484:	431bde83 	.word	0x431bde83

08002488 <RCC_SetFlashLatency>:
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE1   Regulator voltage output range 1 mode
  *            @arg PWR_REGULATOR_VOLTAGE_SCALE2   Regulator voltage output range 2 mode
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 8002488:	b580      	push	{r7, lr}
 800248a:	b08e      	sub	sp, #56	; 0x38
 800248c:	af00      	add	r7, sp, #0
 800248e:	6078      	str	r0, [r7, #4]
 8002490:	6039      	str	r1, [r7, #0]
  /* Flash Clock source (HCLK3) range in MHz for VCORE range1 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS1[] = {18, 36, 48};
 8002492:	4a3a      	ldr	r2, [pc, #232]	; (800257c <RCC_SetFlashLatency+0xf4>)
 8002494:	f107 0320 	add.w	r3, r7, #32
 8002498:	e892 0003 	ldmia.w	r2, {r0, r1}
 800249c:	6018      	str	r0, [r3, #0]
 800249e:	3304      	adds	r3, #4
 80024a0:	8019      	strh	r1, [r3, #0]

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};
 80024a2:	4a37      	ldr	r2, [pc, #220]	; (8002580 <RCC_SetFlashLatency+0xf8>)
 80024a4:	f107 0318 	add.w	r3, r7, #24
 80024a8:	e892 0003 	ldmia.w	r2, {r0, r1}
 80024ac:	6018      	str	r0, [r3, #0]
 80024ae:	3304      	adds	r3, #4
 80024b0:	8019      	strh	r1, [r3, #0]

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 80024b2:	4a34      	ldr	r2, [pc, #208]	; (8002584 <RCC_SetFlashLatency+0xfc>)
 80024b4:	f107 030c 	add.w	r3, r7, #12
 80024b8:	ca07      	ldmia	r2, {r0, r1, r2}
 80024ba:	e883 0007 	stmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 80024be:	2300      	movs	r3, #0
 80024c0:	637b      	str	r3, [r7, #52]	; 0x34
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 80024c2:	683b      	ldr	r3, [r7, #0]
 80024c4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80024c8:	d11b      	bne.n	8002502 <RCC_SetFlashLatency+0x7a>
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 80024ca:	2300      	movs	r3, #0
 80024cc:	633b      	str	r3, [r7, #48]	; 0x30
 80024ce:	e014      	b.n	80024fa <RCC_SetFlashLatency+0x72>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 80024d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80024d2:	005b      	lsls	r3, r3, #1
 80024d4:	3338      	adds	r3, #56	; 0x38
 80024d6:	443b      	add	r3, r7
 80024d8:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 80024dc:	461a      	mov	r2, r3
 80024de:	687b      	ldr	r3, [r7, #4]
 80024e0:	4293      	cmp	r3, r2
 80024e2:	d807      	bhi.n	80024f4 <RCC_SetFlashLatency+0x6c>
      {
        latency = FLASH_LATENCY_RANGE[index];
 80024e4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80024e6:	009b      	lsls	r3, r3, #2
 80024e8:	3338      	adds	r3, #56	; 0x38
 80024ea:	443b      	add	r3, r7
 80024ec:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 80024f0:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 80024f2:	e021      	b.n	8002538 <RCC_SetFlashLatency+0xb0>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 80024f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80024f6:	3301      	adds	r3, #1
 80024f8:	633b      	str	r3, [r7, #48]	; 0x30
 80024fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80024fc:	2b02      	cmp	r3, #2
 80024fe:	d9e7      	bls.n	80024d0 <RCC_SetFlashLatency+0x48>
 8002500:	e01a      	b.n	8002538 <RCC_SetFlashLatency+0xb0>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8002502:	2300      	movs	r3, #0
 8002504:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002506:	e014      	b.n	8002532 <RCC_SetFlashLatency+0xaa>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 8002508:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800250a:	005b      	lsls	r3, r3, #1
 800250c:	3338      	adds	r3, #56	; 0x38
 800250e:	443b      	add	r3, r7
 8002510:	f833 3c20 	ldrh.w	r3, [r3, #-32]
 8002514:	461a      	mov	r2, r3
 8002516:	687b      	ldr	r3, [r7, #4]
 8002518:	4293      	cmp	r3, r2
 800251a:	d807      	bhi.n	800252c <RCC_SetFlashLatency+0xa4>
      {
        latency = FLASH_LATENCY_RANGE[index];
 800251c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800251e:	009b      	lsls	r3, r3, #2
 8002520:	3338      	adds	r3, #56	; 0x38
 8002522:	443b      	add	r3, r7
 8002524:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8002528:	637b      	str	r3, [r7, #52]	; 0x34
        break;
 800252a:	e005      	b.n	8002538 <RCC_SetFlashLatency+0xb0>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800252c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800252e:	3301      	adds	r3, #1
 8002530:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002532:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002534:	2b02      	cmp	r3, #2
 8002536:	d9e7      	bls.n	8002508 <RCC_SetFlashLatency+0x80>
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8002538:	4b13      	ldr	r3, [pc, #76]	; (8002588 <RCC_SetFlashLatency+0x100>)
 800253a:	681b      	ldr	r3, [r3, #0]
 800253c:	f023 0207 	bic.w	r2, r3, #7
 8002540:	4911      	ldr	r1, [pc, #68]	; (8002588 <RCC_SetFlashLatency+0x100>)
 8002542:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002544:	4313      	orrs	r3, r2
 8002546:	600b      	str	r3, [r1, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8002548:	f7fe f82e 	bl	80005a8 <HAL_GetTick>
 800254c:	62b8      	str	r0, [r7, #40]	; 0x28

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800254e:	e008      	b.n	8002562 <RCC_SetFlashLatency+0xda>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8002550:	f7fe f82a 	bl	80005a8 <HAL_GetTick>
 8002554:	4602      	mov	r2, r0
 8002556:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002558:	1ad3      	subs	r3, r2, r3
 800255a:	2b02      	cmp	r3, #2
 800255c:	d901      	bls.n	8002562 <RCC_SetFlashLatency+0xda>
    {
      return HAL_TIMEOUT;
 800255e:	2303      	movs	r3, #3
 8002560:	e007      	b.n	8002572 <RCC_SetFlashLatency+0xea>
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8002562:	4b09      	ldr	r3, [pc, #36]	; (8002588 <RCC_SetFlashLatency+0x100>)
 8002564:	681b      	ldr	r3, [r3, #0]
 8002566:	f003 0307 	and.w	r3, r3, #7
 800256a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800256c:	429a      	cmp	r2, r3
 800256e:	d1ef      	bne.n	8002550 <RCC_SetFlashLatency+0xc8>
    }
  }
  return HAL_OK;
 8002570:	2300      	movs	r3, #0
}
 8002572:	4618      	mov	r0, r3
 8002574:	3738      	adds	r7, #56	; 0x38
 8002576:	46bd      	mov	sp, r7
 8002578:	bd80      	pop	{r7, pc}
 800257a:	bf00      	nop
 800257c:	08002a18 	.word	0x08002a18
 8002580:	08002a20 	.word	0x08002a20
 8002584:	08002a28 	.word	0x08002a28
 8002588:	58004000 	.word	0x58004000

0800258c <LL_RCC_LSE_IsReady>:
{
 800258c:	b480      	push	{r7}
 800258e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8002590:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002594:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002598:	f003 0302 	and.w	r3, r3, #2
 800259c:	2b02      	cmp	r3, #2
 800259e:	d101      	bne.n	80025a4 <LL_RCC_LSE_IsReady+0x18>
 80025a0:	2301      	movs	r3, #1
 80025a2:	e000      	b.n	80025a6 <LL_RCC_LSE_IsReady+0x1a>
 80025a4:	2300      	movs	r3, #0
}
 80025a6:	4618      	mov	r0, r3
 80025a8:	46bd      	mov	sp, r7
 80025aa:	bc80      	pop	{r7}
 80025ac:	4770      	bx	lr

080025ae <LL_RCC_SetUSARTClockSource>:
{
 80025ae:	b480      	push	{r7}
 80025b0:	b083      	sub	sp, #12
 80025b2:	af00      	add	r7, sp, #0
 80025b4:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 80025b6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80025ba:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80025be:	687b      	ldr	r3, [r7, #4]
 80025c0:	0c1b      	lsrs	r3, r3, #16
 80025c2:	43db      	mvns	r3, r3
 80025c4:	401a      	ands	r2, r3
 80025c6:	687b      	ldr	r3, [r7, #4]
 80025c8:	b29b      	uxth	r3, r3
 80025ca:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80025ce:	4313      	orrs	r3, r2
 80025d0:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80025d4:	bf00      	nop
 80025d6:	370c      	adds	r7, #12
 80025d8:	46bd      	mov	sp, r7
 80025da:	bc80      	pop	{r7}
 80025dc:	4770      	bx	lr

080025de <LL_RCC_SetI2SClockSource>:
{
 80025de:	b480      	push	{r7}
 80025e0:	b083      	sub	sp, #12
 80025e2:	af00      	add	r7, sp, #0
 80025e4:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 80025e6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80025ea:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80025ee:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80025f2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80025f6:	687b      	ldr	r3, [r7, #4]
 80025f8:	4313      	orrs	r3, r2
 80025fa:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80025fe:	bf00      	nop
 8002600:	370c      	adds	r7, #12
 8002602:	46bd      	mov	sp, r7
 8002604:	bc80      	pop	{r7}
 8002606:	4770      	bx	lr

08002608 <LL_RCC_SetLPUARTClockSource>:
{
 8002608:	b480      	push	{r7}
 800260a:	b083      	sub	sp, #12
 800260c:	af00      	add	r7, sp, #0
 800260e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8002610:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002614:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002618:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 800261c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8002620:	687b      	ldr	r3, [r7, #4]
 8002622:	4313      	orrs	r3, r2
 8002624:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8002628:	bf00      	nop
 800262a:	370c      	adds	r7, #12
 800262c:	46bd      	mov	sp, r7
 800262e:	bc80      	pop	{r7}
 8002630:	4770      	bx	lr

08002632 <LL_RCC_SetI2CClockSource>:
{
 8002632:	b480      	push	{r7}
 8002634:	b083      	sub	sp, #12
 8002636:	af00      	add	r7, sp, #0
 8002638:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 800263a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800263e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8002642:	687b      	ldr	r3, [r7, #4]
 8002644:	091b      	lsrs	r3, r3, #4
 8002646:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 800264a:	43db      	mvns	r3, r3
 800264c:	401a      	ands	r2, r3
 800264e:	687b      	ldr	r3, [r7, #4]
 8002650:	011b      	lsls	r3, r3, #4
 8002652:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8002656:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800265a:	4313      	orrs	r3, r2
 800265c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8002660:	bf00      	nop
 8002662:	370c      	adds	r7, #12
 8002664:	46bd      	mov	sp, r7
 8002666:	bc80      	pop	{r7}
 8002668:	4770      	bx	lr

0800266a <LL_RCC_SetLPTIMClockSource>:
{
 800266a:	b480      	push	{r7}
 800266c:	b083      	sub	sp, #12
 800266e:	af00      	add	r7, sp, #0
 8002670:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8002672:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002676:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800267a:	687b      	ldr	r3, [r7, #4]
 800267c:	0c1b      	lsrs	r3, r3, #16
 800267e:	041b      	lsls	r3, r3, #16
 8002680:	43db      	mvns	r3, r3
 8002682:	401a      	ands	r2, r3
 8002684:	687b      	ldr	r3, [r7, #4]
 8002686:	041b      	lsls	r3, r3, #16
 8002688:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800268c:	4313      	orrs	r3, r2
 800268e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8002692:	bf00      	nop
 8002694:	370c      	adds	r7, #12
 8002696:	46bd      	mov	sp, r7
 8002698:	bc80      	pop	{r7}
 800269a:	4770      	bx	lr

0800269c <LL_RCC_SetRNGClockSource>:
{
 800269c:	b480      	push	{r7}
 800269e:	b083      	sub	sp, #12
 80026a0:	af00      	add	r7, sp, #0
 80026a2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80026a4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80026a8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80026ac:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
 80026b0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	4313      	orrs	r3, r2
 80026b8:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80026bc:	bf00      	nop
 80026be:	370c      	adds	r7, #12
 80026c0:	46bd      	mov	sp, r7
 80026c2:	bc80      	pop	{r7}
 80026c4:	4770      	bx	lr

080026c6 <LL_RCC_SetADCClockSource>:
{
 80026c6:	b480      	push	{r7}
 80026c8:	b083      	sub	sp, #12
 80026ca:	af00      	add	r7, sp, #0
 80026cc:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 80026ce:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80026d2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80026d6:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 80026da:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80026de:	687b      	ldr	r3, [r7, #4]
 80026e0:	4313      	orrs	r3, r2
 80026e2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80026e6:	bf00      	nop
 80026e8:	370c      	adds	r7, #12
 80026ea:	46bd      	mov	sp, r7
 80026ec:	bc80      	pop	{r7}
 80026ee:	4770      	bx	lr

080026f0 <LL_RCC_SetRTCClockSource>:
{
 80026f0:	b480      	push	{r7}
 80026f2:	b083      	sub	sp, #12
 80026f4:	af00      	add	r7, sp, #0
 80026f6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 80026f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80026fc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002700:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8002704:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8002708:	687b      	ldr	r3, [r7, #4]
 800270a:	4313      	orrs	r3, r2
 800270c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 8002710:	bf00      	nop
 8002712:	370c      	adds	r7, #12
 8002714:	46bd      	mov	sp, r7
 8002716:	bc80      	pop	{r7}
 8002718:	4770      	bx	lr

0800271a <LL_RCC_GetRTCClockSource>:
{
 800271a:	b480      	push	{r7}
 800271c:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 800271e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002722:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8002726:	f403 7340 	and.w	r3, r3, #768	; 0x300
}
 800272a:	4618      	mov	r0, r3
 800272c:	46bd      	mov	sp, r7
 800272e:	bc80      	pop	{r7}
 8002730:	4770      	bx	lr

08002732 <LL_RCC_ForceBackupDomainReset>:
{
 8002732:	b480      	push	{r7}
 8002734:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8002736:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800273a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800273e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8002742:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002746:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800274a:	bf00      	nop
 800274c:	46bd      	mov	sp, r7
 800274e:	bc80      	pop	{r7}
 8002750:	4770      	bx	lr

08002752 <LL_RCC_ReleaseBackupDomainReset>:
{
 8002752:	b480      	push	{r7}
 8002754:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8002756:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800275a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800275e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8002762:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8002766:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800276a:	bf00      	nop
 800276c:	46bd      	mov	sp, r7
 800276e:	bc80      	pop	{r7}
 8002770:	4770      	bx	lr
	...

08002774 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002774:	b580      	push	{r7, lr}
 8002776:	b086      	sub	sp, #24
 8002778:	af00      	add	r7, sp, #0
 800277a:	6078      	str	r0, [r7, #4]
  uint32_t tmpregister = 0;
 800277c:	2300      	movs	r3, #0
 800277e:	617b      	str	r3, [r7, #20]
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;   /* Intermediate status */
 8002780:	2300      	movs	r3, #0
 8002782:	74fb      	strb	r3, [r7, #19]
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8002784:	2300      	movs	r3, #0
 8002786:	74bb      	strb	r3, [r7, #18]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8002788:	687b      	ldr	r3, [r7, #4]
 800278a:	681b      	ldr	r3, [r3, #0]
 800278c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002790:	2b00      	cmp	r3, #0
 8002792:	d058      	beq.n	8002846 <HAL_RCCEx_PeriphCLKConfig+0xd2>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 8002794:	f7fe fe16 	bl	80013c4 <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8002798:	f7fd ff06 	bl	80005a8 <HAL_GetTick>
 800279c:	60f8      	str	r0, [r7, #12]

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 800279e:	e009      	b.n	80027b4 <HAL_RCCEx_PeriphCLKConfig+0x40>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80027a0:	f7fd ff02 	bl	80005a8 <HAL_GetTick>
 80027a4:	4602      	mov	r2, r0
 80027a6:	68fb      	ldr	r3, [r7, #12]
 80027a8:	1ad3      	subs	r3, r2, r3
 80027aa:	2b02      	cmp	r3, #2
 80027ac:	d902      	bls.n	80027b4 <HAL_RCCEx_PeriphCLKConfig+0x40>
      {
        ret = HAL_TIMEOUT;
 80027ae:	2303      	movs	r3, #3
 80027b0:	74fb      	strb	r3, [r7, #19]
        break;
 80027b2:	e006      	b.n	80027c2 <HAL_RCCEx_PeriphCLKConfig+0x4e>
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 80027b4:	4b7b      	ldr	r3, [pc, #492]	; (80029a4 <HAL_RCCEx_PeriphCLKConfig+0x230>)
 80027b6:	681b      	ldr	r3, [r3, #0]
 80027b8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80027bc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80027c0:	d1ee      	bne.n	80027a0 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      }
    }

    if (ret == HAL_OK)
 80027c2:	7cfb      	ldrb	r3, [r7, #19]
 80027c4:	2b00      	cmp	r3, #0
 80027c6:	d13c      	bne.n	8002842 <HAL_RCCEx_PeriphCLKConfig+0xce>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 80027c8:	f7ff ffa7 	bl	800271a <LL_RCC_GetRTCClockSource>
 80027cc:	4602      	mov	r2, r0
 80027ce:	687b      	ldr	r3, [r7, #4]
 80027d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80027d2:	429a      	cmp	r2, r3
 80027d4:	d00f      	beq.n	80027f6 <HAL_RCCEx_PeriphCLKConfig+0x82>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80027d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80027da:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80027de:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80027e2:	617b      	str	r3, [r7, #20]

        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 80027e4:	f7ff ffa5 	bl	8002732 <LL_RCC_ForceBackupDomainReset>
        __HAL_RCC_BACKUPRESET_RELEASE();
 80027e8:	f7ff ffb3 	bl	8002752 <LL_RCC_ReleaseBackupDomainReset>

        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
 80027ec:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80027f0:	697b      	ldr	r3, [r7, #20]
 80027f2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 80027f6:	697b      	ldr	r3, [r7, #20]
 80027f8:	f003 0302 	and.w	r3, r3, #2
 80027fc:	2b00      	cmp	r3, #0
 80027fe:	d014      	beq.n	800282a <HAL_RCCEx_PeriphCLKConfig+0xb6>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002800:	f7fd fed2 	bl	80005a8 <HAL_GetTick>
 8002804:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() != 1U)
 8002806:	e00b      	b.n	8002820 <HAL_RCCEx_PeriphCLKConfig+0xac>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002808:	f7fd fece 	bl	80005a8 <HAL_GetTick>
 800280c:	4602      	mov	r2, r0
 800280e:	68fb      	ldr	r3, [r7, #12]
 8002810:	1ad3      	subs	r3, r2, r3
 8002812:	f241 3288 	movw	r2, #5000	; 0x1388
 8002816:	4293      	cmp	r3, r2
 8002818:	d902      	bls.n	8002820 <HAL_RCCEx_PeriphCLKConfig+0xac>
          {
            ret = HAL_TIMEOUT;
 800281a:	2303      	movs	r3, #3
 800281c:	74fb      	strb	r3, [r7, #19]
            break;
 800281e:	e004      	b.n	800282a <HAL_RCCEx_PeriphCLKConfig+0xb6>
        while (LL_RCC_LSE_IsReady() != 1U)
 8002820:	f7ff feb4 	bl	800258c <LL_RCC_LSE_IsReady>
 8002824:	4603      	mov	r3, r0
 8002826:	2b01      	cmp	r3, #1
 8002828:	d1ee      	bne.n	8002808 <HAL_RCCEx_PeriphCLKConfig+0x94>
          }
        }
      }

      if (ret == HAL_OK)
 800282a:	7cfb      	ldrb	r3, [r7, #19]
 800282c:	2b00      	cmp	r3, #0
 800282e:	d105      	bne.n	800283c <HAL_RCCEx_PeriphCLKConfig+0xc8>
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002830:	687b      	ldr	r3, [r7, #4]
 8002832:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002834:	4618      	mov	r0, r3
 8002836:	f7ff ff5b 	bl	80026f0 <LL_RCC_SetRTCClockSource>
 800283a:	e004      	b.n	8002846 <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
      else
      {
        /* set overall return value */
        status = ret;
 800283c:	7cfb      	ldrb	r3, [r7, #19]
 800283e:	74bb      	strb	r3, [r7, #18]
 8002840:	e001      	b.n	8002846 <HAL_RCCEx_PeriphCLKConfig+0xd2>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8002842:	7cfb      	ldrb	r3, [r7, #19]
 8002844:	74bb      	strb	r3, [r7, #18]
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8002846:	687b      	ldr	r3, [r7, #4]
 8002848:	681b      	ldr	r3, [r3, #0]
 800284a:	f003 0301 	and.w	r3, r3, #1
 800284e:	2b00      	cmp	r3, #0
 8002850:	d004      	beq.n	800285c <HAL_RCCEx_PeriphCLKConfig+0xe8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8002852:	687b      	ldr	r3, [r7, #4]
 8002854:	685b      	ldr	r3, [r3, #4]
 8002856:	4618      	mov	r0, r3
 8002858:	f7ff fea9 	bl	80025ae <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800285c:	687b      	ldr	r3, [r7, #4]
 800285e:	681b      	ldr	r3, [r3, #0]
 8002860:	f003 0302 	and.w	r3, r3, #2
 8002864:	2b00      	cmp	r3, #0
 8002866:	d004      	beq.n	8002872 <HAL_RCCEx_PeriphCLKConfig+0xfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8002868:	687b      	ldr	r3, [r7, #4]
 800286a:	689b      	ldr	r3, [r3, #8]
 800286c:	4618      	mov	r0, r3
 800286e:	f7ff fe9e 	bl	80025ae <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8002872:	687b      	ldr	r3, [r7, #4]
 8002874:	681b      	ldr	r3, [r3, #0]
 8002876:	f003 0320 	and.w	r3, r3, #32
 800287a:	2b00      	cmp	r3, #0
 800287c:	d004      	beq.n	8002888 <HAL_RCCEx_PeriphCLKConfig+0x114>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800287e:	687b      	ldr	r3, [r7, #4]
 8002880:	691b      	ldr	r3, [r3, #16]
 8002882:	4618      	mov	r0, r3
 8002884:	f7ff fec0 	bl	8002608 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8002888:	687b      	ldr	r3, [r7, #4]
 800288a:	681b      	ldr	r3, [r3, #0]
 800288c:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002890:	2b00      	cmp	r3, #0
 8002892:	d004      	beq.n	800289e <HAL_RCCEx_PeriphCLKConfig+0x12a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8002894:	687b      	ldr	r3, [r7, #4]
 8002896:	6a1b      	ldr	r3, [r3, #32]
 8002898:	4618      	mov	r0, r3
 800289a:	f7ff fee6 	bl	800266a <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 800289e:	687b      	ldr	r3, [r7, #4]
 80028a0:	681b      	ldr	r3, [r3, #0]
 80028a2:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80028a6:	2b00      	cmp	r3, #0
 80028a8:	d004      	beq.n	80028b4 <HAL_RCCEx_PeriphCLKConfig+0x140>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80028aa:	687b      	ldr	r3, [r7, #4]
 80028ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80028ae:	4618      	mov	r0, r3
 80028b0:	f7ff fedb 	bl	800266a <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 80028b4:	687b      	ldr	r3, [r7, #4]
 80028b6:	681b      	ldr	r3, [r3, #0]
 80028b8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80028bc:	2b00      	cmp	r3, #0
 80028be:	d004      	beq.n	80028ca <HAL_RCCEx_PeriphCLKConfig+0x156>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 80028c0:	687b      	ldr	r3, [r7, #4]
 80028c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80028c4:	4618      	mov	r0, r3
 80028c6:	f7ff fed0 	bl	800266a <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80028ca:	687b      	ldr	r3, [r7, #4]
 80028cc:	681b      	ldr	r3, [r3, #0]
 80028ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80028d2:	2b00      	cmp	r3, #0
 80028d4:	d004      	beq.n	80028e0 <HAL_RCCEx_PeriphCLKConfig+0x16c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80028d6:	687b      	ldr	r3, [r7, #4]
 80028d8:	695b      	ldr	r3, [r3, #20]
 80028da:	4618      	mov	r0, r3
 80028dc:	f7ff fea9 	bl	8002632 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80028e0:	687b      	ldr	r3, [r7, #4]
 80028e2:	681b      	ldr	r3, [r3, #0]
 80028e4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80028e8:	2b00      	cmp	r3, #0
 80028ea:	d004      	beq.n	80028f6 <HAL_RCCEx_PeriphCLKConfig+0x182>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80028ec:	687b      	ldr	r3, [r7, #4]
 80028ee:	699b      	ldr	r3, [r3, #24]
 80028f0:	4618      	mov	r0, r3
 80028f2:	f7ff fe9e 	bl	8002632 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80028f6:	687b      	ldr	r3, [r7, #4]
 80028f8:	681b      	ldr	r3, [r3, #0]
 80028fa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80028fe:	2b00      	cmp	r3, #0
 8002900:	d004      	beq.n	800290c <HAL_RCCEx_PeriphCLKConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8002902:	687b      	ldr	r3, [r7, #4]
 8002904:	69db      	ldr	r3, [r3, #28]
 8002906:	4618      	mov	r0, r3
 8002908:	f7ff fe93 	bl	8002632 <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 800290c:	687b      	ldr	r3, [r7, #4]
 800290e:	681b      	ldr	r3, [r3, #0]
 8002910:	f003 0310 	and.w	r3, r3, #16
 8002914:	2b00      	cmp	r3, #0
 8002916:	d011      	beq.n	800293c <HAL_RCCEx_PeriphCLKConfig+0x1c8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 8002918:	687b      	ldr	r3, [r7, #4]
 800291a:	68db      	ldr	r3, [r3, #12]
 800291c:	4618      	mov	r0, r3
 800291e:	f7ff fe5e 	bl	80025de <LL_RCC_SetI2SClockSource>

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 8002922:	687b      	ldr	r3, [r7, #4]
 8002924:	68db      	ldr	r3, [r3, #12]
 8002926:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800292a:	d107      	bne.n	800293c <HAL_RCCEx_PeriphCLKConfig+0x1c8>
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 800292c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002930:	68db      	ldr	r3, [r3, #12]
 8002932:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8002936:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800293a:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 800293c:	687b      	ldr	r3, [r7, #4]
 800293e:	681b      	ldr	r3, [r3, #0]
 8002940:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002944:	2b00      	cmp	r3, #0
 8002946:	d010      	beq.n	800296a <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800294c:	4618      	mov	r0, r3
 800294e:	f7ff fea5 	bl	800269c <LL_RCC_SetRNGClockSource>

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8002952:	687b      	ldr	r3, [r7, #4]
 8002954:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002956:	2b00      	cmp	r3, #0
 8002958:	d107      	bne.n	800296a <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 800295a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800295e:	68db      	ldr	r3, [r3, #12]
 8002960:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8002964:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002968:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800296a:	687b      	ldr	r3, [r7, #4]
 800296c:	681b      	ldr	r3, [r3, #0]
 800296e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002972:	2b00      	cmp	r3, #0
 8002974:	d011      	beq.n	800299a <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8002976:	687b      	ldr	r3, [r7, #4]
 8002978:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800297a:	4618      	mov	r0, r3
 800297c:	f7ff fea3 	bl	80026c6 <LL_RCC_SetADCClockSource>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 8002980:	687b      	ldr	r3, [r7, #4]
 8002982:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002984:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8002988:	d107      	bne.n	800299a <HAL_RCCEx_PeriphCLKConfig+0x226>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 800298a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800298e:	68db      	ldr	r3, [r3, #12]
 8002990:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8002994:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002998:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
 800299a:	7cbb      	ldrb	r3, [r7, #18]
}
 800299c:	4618      	mov	r0, r3
 800299e:	3718      	adds	r7, #24
 80029a0:	46bd      	mov	sp, r7
 80029a2:	bd80      	pop	{r7, pc}
 80029a4:	58000400 	.word	0x58000400

080029a8 <__libc_init_array>:
 80029a8:	b570      	push	{r4, r5, r6, lr}
 80029aa:	4d0d      	ldr	r5, [pc, #52]	; (80029e0 <__libc_init_array+0x38>)
 80029ac:	4c0d      	ldr	r4, [pc, #52]	; (80029e4 <__libc_init_array+0x3c>)
 80029ae:	1b64      	subs	r4, r4, r5
 80029b0:	10a4      	asrs	r4, r4, #2
 80029b2:	2600      	movs	r6, #0
 80029b4:	42a6      	cmp	r6, r4
 80029b6:	d109      	bne.n	80029cc <__libc_init_array+0x24>
 80029b8:	4d0b      	ldr	r5, [pc, #44]	; (80029e8 <__libc_init_array+0x40>)
 80029ba:	4c0c      	ldr	r4, [pc, #48]	; (80029ec <__libc_init_array+0x44>)
 80029bc:	f000 f820 	bl	8002a00 <_init>
 80029c0:	1b64      	subs	r4, r4, r5
 80029c2:	10a4      	asrs	r4, r4, #2
 80029c4:	2600      	movs	r6, #0
 80029c6:	42a6      	cmp	r6, r4
 80029c8:	d105      	bne.n	80029d6 <__libc_init_array+0x2e>
 80029ca:	bd70      	pop	{r4, r5, r6, pc}
 80029cc:	f855 3b04 	ldr.w	r3, [r5], #4
 80029d0:	4798      	blx	r3
 80029d2:	3601      	adds	r6, #1
 80029d4:	e7ee      	b.n	80029b4 <__libc_init_array+0xc>
 80029d6:	f855 3b04 	ldr.w	r3, [r5], #4
 80029da:	4798      	blx	r3
 80029dc:	3601      	adds	r6, #1
 80029de:	e7f2      	b.n	80029c6 <__libc_init_array+0x1e>
 80029e0:	08002ab4 	.word	0x08002ab4
 80029e4:	08002ab4 	.word	0x08002ab4
 80029e8:	08002ab4 	.word	0x08002ab4
 80029ec:	08002ab8 	.word	0x08002ab8

080029f0 <memset>:
 80029f0:	4402      	add	r2, r0
 80029f2:	4603      	mov	r3, r0
 80029f4:	4293      	cmp	r3, r2
 80029f6:	d100      	bne.n	80029fa <memset+0xa>
 80029f8:	4770      	bx	lr
 80029fa:	f803 1b01 	strb.w	r1, [r3], #1
 80029fe:	e7f9      	b.n	80029f4 <memset+0x4>

08002a00 <_init>:
 8002a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a02:	bf00      	nop
 8002a04:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002a06:	bc08      	pop	{r3}
 8002a08:	469e      	mov	lr, r3
 8002a0a:	4770      	bx	lr

08002a0c <_fini>:
 8002a0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a0e:	bf00      	nop
 8002a10:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8002a12:	bc08      	pop	{r3}
 8002a14:	469e      	mov	lr, r3
 8002a16:	4770      	bx	lr
